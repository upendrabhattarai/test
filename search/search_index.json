{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"Introduction to R Audience Computational skills required Duration Biologists None 4-session online workshop (~ 8 hours of trainer-led time)"},{"location":"#description","title":"Description","text":"<p>This repository has teaching materials for a hands-on Introduction to R workshop taught online. The workshop will introduce participants to the basics of R and RStudio. R is a simple programming environment that enables the effective handling of data, while providing excellent graphical support. RStudio is a tool that provides a user-friendly environment for working with R. These materials are intended to provide both basic R programming knowledge and its application for increasing efficiency for data analysis. </p> <p>Note for Trainers</p> <p>The schedule linked below assumes that learners will spend between 2-3 hours on reading through, and completing exercises from selected lessons between classes. The online component of the workshop focuses on more exercises and discussion.</p>"},{"location":"#learning-objectives","title":"Learning Objectives","text":"<ol> <li> <p>R syntax: </p> <p>Familiarize the basic syntax and the use of Rstudio.</p> </li> <li> <p>Data types and data structures: </p> <p>Describe frequently-used data types and data structures in R.</p> </li> <li> <p>Data inspection and wrangling: </p> <p>Demonstrate the utilization of functions and indices to inspect and subset data from various data structures.</p> </li> <li> <p>Data visualization:</p> <p>Apply the ggplot2 package to create plots for data visualization.</p> </li> </ol>"},{"location":"#setup-requirements","title":"Setup Requirements","text":"<p>Download the most recent version of R and RStudio for the appropriate OS following the links below. </p> <p> R software download</p> <p> RStudio download</p> <p>All the data files used in the lessons are linked within, but can also be accessed through the link below.</p> <p> Dataset download</p>"},{"location":"#lessons","title":"Lessons","text":"<ul> <li> <p>Trainer led workshop Click here</p> </li> <li> <p>Self learning materials Click here</p> </li> </ul> <p>Attribution &amp; Citation</p> <ul> <li> <p>These materials have been developed by members of the teaching team at the Harvard Chan Bioinformatics Core (HBC). These are open access materials distributed under the terms of the Creative Commons Attribution license (CC BY 4.0), which permits unrestricted use, distribution, and reproduction in any medium, provided the original author and source are credited.</p> </li> <li> <p>Some materials used in these lessons were derived from work that is Copyright \u00a9 Data Carpentry. All Data Carpentry instructional material is made available under the Creative Commons Attribution license (CC BY 4.0)</p> </li> <li> <p>To cite material from this course in your publications, please use:</p> <p>Meeta Mistry, Mary Piper, Jihe Liu, &amp; Radhika Khetani. (2021, May 5). hbctraining/Intro-to-R-flipped: R workshop first release. Zenodo. https://doi.org/10.5281/zenodo.4739342</p> </li> <li> <p>A lot of time and effort went into the preparation of these materials. Citations help us understand the needs of the community, gain recognition for our work, and attract further funding to support our teaching activities. Thank you for citing this material if it helped you in your data analysis.</p> </li> </ul>"},{"location":"Workshop_Schedule/","title":"Workshop Schedule","text":"Workshop Schedule"},{"location":"Workshop_Schedule/#day-1","title":"Day 1","text":"Lesson Overview Instructor Time Workshop Introduction Welcome and housekeeping Will 10:00-10:30 Intro to R and RStudio Introduction to R and RStudio Elizabeth 10:30-11:45 Self learning materials Overview of self-learning materials Will 11:45-12:00"},{"location":"Workshop_Schedule/#before-the-next-class","title":"Before the next class","text":"<p>A. Please study the contents and work through all the code within the following lessons.</p> <p>B. Complete the exercises:</p> <ul> <li> <p>Each lesson above contains exercises; please go through each of them.</p> </li> <li> <p>Copy over your solutions into the Google Form using the submit link below the day before the next class</p> </li> </ul> <p>Questions?</p> <p>If you get stuck due to an error while running code in the lesson, email us</p> <ul> <li> <p>1. R Syntax and Data Structure</p> About data types and data structure <p>In order to utilize R effectively, you will need to understand what types of data you can use in R and also how you can store data in \"objects\" or \"variables\".</p> <p>This lesson will cover:</p> <ul> <li> <p>Assigning a value to a object</p> </li> <li> <p>What types of information can you store in R</p> </li> <li> <p>What are the different objects that you can use to store data in R</p> </li> </ul> </li> </ul> <ul> <li> <p>2. Functions and Arguments</p> Functions and Arguments in R <p>Functions are the basic \"commands\" used in R to get something done. To use functions (denoted by function_name followed by \"()\"), one has to enter some information within the parenthesis and optionally some arguments to change the default behavior of a function.</p> <p>You can also create your own functions! When you want to perform a task or a series of tasks more than once, creating a custom function is the best way to go.</p> <p>In this lesson you will explore:</p> <ul> <li> <p>Using built-in functions</p> </li> <li> <p>Creating your own custom functions</p> </li> </ul> </li> </ul> <ul> <li> <p>3. Reading in and inspecting data</p> Read and inspect data structures in R <p>When using R, it is almost a certainty that you will have to bring data into the R environment.</p> <p>In this lesson you will learn:</p> <ul> <li> <p>Reading different types (formats) of data</p> </li> <li> <p>Inspecting the contents and structure of the dataset once you have read it in</p> </li> </ul> </li> </ul> <ul> <li> <p>Submit here:</p> <p>Submit a day before the next class.</p> </li> </ul>"},{"location":"Workshop_Schedule/#day-2","title":"Day 2","text":"Lesson Overview Instructor Time Review self-learning Questions about self-learning All 10:00-10:50 In-class exercises  Use and customize function and arguments Elizabeth 10:50-11:15 Data Wrangling Subsetting Vectors and Factors Will 11:15-12:00"},{"location":"Workshop_Schedule/#before-the-next-class_1","title":"Before the next class","text":"<p>A. Please study the contents and work through all the code within the following lessons.</p> <p>B. Complete the exercises:</p> <ul> <li> <p>Each lesson above contains exercises; please go through each of them.</p> </li> <li> <p>Copy over your solutions into the Google Form using the submit link below the day before the next class</p> </li> </ul> <p>Questions?</p> <p>If you get stuck due to an error while running code in the lesson, email us</p> <ul> <li> <p>1. Packages and libraries</p> Installing and loading packages in R <p>Base R is incredibly powerful, but it cannot do everything. R has been built to encourage community involvement in expanding functionality. Thousands of supplemental add-ons, also called \"packages\" have been contributed by the community. Each package comprises of several functions that enable users to perform their desired analysis.</p> <p>This lesson will cover:</p> <ul> <li> <p>Descriptions of package repositories</p> </li> <li> <p>Installing a package</p> </li> <li> <p>Loading a package</p> </li> <li> <p>Accessing the documention for your installed packages and getting help</p> </li> </ul> </li> </ul> <ul> <li> <p>2. Data wrangling: data frames, matrics and lists</p> Subset, merge, and create new datasets <p>In class we covered data wrangling (extracting/subsetting) information from single-dimensional objects (vectors, factors). The next step is to learn how to wrangle data in two-dimensional objects.</p> <p>This lesson will cover:</p> <ul> <li> <p>Examining and extracting values from two-dimensional data structures using indices, row names, or column names</p> </li> <li> <p>Retreiving information from lists</p> </li> </ul> </li> </ul> <ul> <li> <p>3. The %in% operator</p> <code>%in%</code> operator, <code>any</code> and <code>all</code> functions <p>Very often you will have to compare two vectors to figure out if, and which, values are common between them. The %in% operator can be used for this purpose.</p> <p>This lesson will cover:</p> <ul> <li> <p>Implementing the %in% operator to evaluate two vectors</p> </li> <li> <p>Distinguishing %in% from == and other logical operators</p> </li> <li> <p>Using any() and all() functions</p> </li> </ul> </li> </ul> <ul> <li> <p>4. Reordering and matching</p> Ordering of vectors and data frames <p>Sometimes you will want to rearrange values within a vector (row names or column names). The match() function can be very powerful for this task.</p> <p>This lesson will cover:</p> <ul> <li> <p>Maunually rearranging values within a vector</p> </li> <li> <p>Implementing the match() function to automatically rearrange the values within a vector</p> </li> </ul> </li> </ul> <ul> <li> <p>5. Data frame for plotting</p> Learn about <code>map()</code> function for iterative tasks <p>We will be starting with visualization in the next class. To set up for this, you need to create a new metadata data frame with information from the counts data frame. You will need to use a function over every column within the counts data frame iteratively. You could do that manually, but it is error-prone; the map() family of functions makes this more efficient.</p> <p>This lesson will cover:</p> <ul> <li> <p>Utilizing map_dbl() to take the average of every column in a data frame</p> </li> <li> <p>Briefly discuss other functions within the map() family of functions</p> </li> <li> <p>Create a new data frame for plotting</p> </li> </ul> </li> </ul> <ul> <li> <p>Submit here</p> <p>Submit a day before the next class.</p> </li> </ul> <p>Prepare for in-class exercise:</p> <ul> <li>Download the data and place the file into the <code>data</code> directory.</li> </ul> Data Download link Animal data Right click &amp; Save link as... <ul> <li> <p>Read the .csv file into your environment and assign it to a variable called animals.      Be sure to check that your row names are the different animals.</p> </li> <li> <p>Save the R project when you close Rstudio.</p> </li> </ul>"},{"location":"Workshop_Schedule/#day-3","title":"Day 3","text":"Lesson Overview Instructor Time Review self-learning Questions about self-learning All 10:00-10:35 In-class exercises  Customizing functions and arguments Will 10:50-11:15 Plotting with ggplot2 ggplot2 for data visualization Elizabeth 11:15-12:00"},{"location":"Workshop_Schedule/#before-the-next-class_2","title":"Before the next class","text":"<ol> <li> <p>Please study the contents and work through all the code within the following lessons.</p> </li> <li> <p>Complete the exercises:</p> </li> <li> <p>Each lesson above contains exercises; please go through each of them.</p> </li> <li> <p>Copy over your solutions into the Google Form using the submit link below the day before the next class</p> </li> </ol> <p>Questions?</p> <p>If you get stuck due to an error while running code in the lesson, email us</p> <ul> <li> <p>1. Custom functions for plots</p> Consistent formats for plotting <p>When creating your plots in ggplot2 you may want to have consistent formatting (using theme() functions) across your plots, e.g. if you are generating plots for a manuscript.</p> <p>This lesson will cover:</p> <ul> <li>Developing a custom function for creating consistently formatted plots</li> </ul> </li> </ul> <ul> <li> <p>2. Boxplot with ggplot2</p> Customizing barplots with ggplot2 <p>Previously, you created a scatterplot using ggplot2. However, ggplot2 can be used to create a very wide variety of plots. One of the other frequently used plots you can create with ggplot2 is a barplot.</p> <p>This lesson will cover:</p> <ul> <li>Creating and customizing a barplot using ggplot2  </li> </ul> </li> </ul> <ul> <li> <p>3. Exporting files and plots</p> Writing files and plots in different formats <p>Now that you have completed some analysis in R, you will need to eventually export that work out of R/RStudio. R provides lots of flexibility in what and how you export your data and plots.</p> <p>This lesson will cover:</p> <ul> <li> <p>Exporting your figures from R using a variety of file formats</p> </li> <li> <p>Writing your data from R to a file</p> </li> </ul> </li> </ul> <ul> <li> <p>4. Finding help</p> How to best look for help <p>Hopefully, this course has given you the basic tools you need to be successful when using R. However, it would be impossible to cover every aspect of R and you will need to be able to troubleshoot future issues as they arise.</p> <p>This lesson will cover:</p> <ul> <li> <p>Suggestions for how to best ask for help</p> </li> <li> <p>Where to look for help</p> </li> </ul> </li> </ul> <ul> <li> <p>5. Tidyverse</p> Data wrangling within Tidyverse <p>The Tidyverse suite of integrated packages are designed to work together to make common data science operations more user friendly. Tidyverse is becoming increasingly prevalent and it is necessary that R users are conversant in the basics of Tidyverse. We have already used two Tidyverse packages in this workshop (ggplot2 and purrr) and in this lesson we will learn some key features from a few additional packages that make up Tidyverse.</p> <p>This lesson will cover:</p> <ul> <li> <p>Usage of pipes for connecting together multiple commands</p> </li> <li> <p>Tibbles for two-dimensional data storage</p> </li> <li> <p>Data wrangling within Tidyverse</p> </li> </ul> </li> </ul> <ul> <li> <p>Submit here</p> <p>Submit a day before the next class.</p> </li> </ul>"},{"location":"Workshop_Schedule/#day-4","title":"Day 4","text":"Lesson Overview Instructor Time Review self-learning Questions about self-learning All 10:00-10:35 In-class exercises  In class exercises Elizabeth 10:50-11:15 Discussion Q&amp;A Will 11:15 - 11:45 Wrap Up Wrap up and checking out Will 11:45 - 12:00"},{"location":"Workshop_Schedule/#additional-exercises-and-answer-keys","title":"Additional exercises and answer keys","text":"<ul> <li>Final Exercises</li> </ul> Answer Keys <ul> <li>Answer Keys Day 1</li> <li>Answer Keys Day 2</li> <li>Answer Keys Day 3</li> <li>Answer Keys Final exercise</li> </ul>"},{"location":"Workshop_Schedule/#additional-resources","title":"Additional resources","text":"<ul> <li> <p>Building on the basic R knowledge</p> <ul> <li>DGE workshop</li> <li>Single-cell RNA-seq workshop</li> <li>RMarkdown</li> <li>Functional analysis</li> <li>More ggplot2</li> <li>ggplot2 cookbook</li> <li>Running R and Rstudio on O2</li> </ul> </li> <li> <p>Resources</p> <ul> <li>Online learning resources</li> <li>All hbctraining materials</li> </ul> <p>Cheatsheets</p> <ul> <li>base R cheatsheet</li> <li>RStudio cheatsheet</li> <li>ggplot2 cheatsheet</li> </ul> </li> </ul> <p>Attribution &amp; Citation</p> <ul> <li> <p>These materials have been developed by members of the teaching team at the Harvard Chan Bioinformatics Core (HBC). These are open access materials distributed under the terms of the Creative Commons Attribution license (CC BY 4.0), which permits unrestricted use, distribution, and reproduction in any medium, provided the original author and source are credited.</p> </li> <li> <p>Some materials used in these lessons were derived from work that is Copyright \u00a9 Data Carpentry. All Data Carpentry instructional material is made available under the Creative Commons Attribution license (CC BY 4.0)</p> </li> <li> <p>To cite material from this course in your publications, please use:</p> <p>Meeta Mistry, Mary Piper, Jihe Liu, &amp; Radhika Khetani. (2021, May 5). hbctraining/Intro-to-R-flipped: R workshop first release. Zenodo. https://doi.org/10.5281/zenodo.4739342</p> </li> <li> <p>A lot of time and effort went into the preparation of these materials. Citations help us understand the needs of the community, gain recognition for our work, and attract further funding to support our teaching activities. Thank you for citing this material if it helped you in your data analysis.</p> </li> </ul>"},{"location":"day_1/D1.2_introR-R-and-RStudio/","title":"Introduction to R and RStudio","text":"<p>Approximate time: 45 minutes</p> <p>Instructors: Meeta and Noor</p>"},{"location":"day_1/D1.2_introR-R-and-RStudio/#learning-objectives","title":"Learning Objectives","text":"<ul> <li>Describe what R and RStudio are.</li> <li>Interact with R using RStudio.</li> <li>Familiarize various components of RStudio.</li> <li>Employ variables in R.</li> </ul>"},{"location":"day_1/D1.2_introR-R-and-RStudio/#what-is-r","title":"What is R?","text":"<p>The common misconception is that R is a programming language but in fact it is much more than that. Think of R as an environment for statistical computing and graphics, which brings together a number of features to provide powerful functionality.</p> <p>The R environment combines:</p> <ul> <li>effective handling of big data </li> <li>collection of integrated tools</li> <li>graphical facilities</li> <li>simple and effective programming language</li> </ul>"},{"location":"day_1/D1.2_introR-R-and-RStudio/#why-use-r","title":"Why use R?","text":"<p>R is a powerful, extensible environment. It has a wide range of statistics and general data analysis and visualization capabilities.</p> <ul> <li>Data handling, wrangling, and storage</li> <li>Wide array of statistical methods and graphical techniques available</li> <li>Easy to install on any platform and use (and it\u2019s free!)</li> <li>Open source with a large and growing community of peers</li> </ul> <p>Examples of R used in the media and science\"  </p> <ul> <li> <p>\"At the BBC data team, we have developed an R package and an R cookbook to make the process of creating publication-ready graphics in our in-house style...\" - BBC Visual and Data Journalism cookbook for R graphics</p> </li> <li> <p>\"R package of data and code behind the stories and interactives at FiveThirtyEight.com, a data-driven journalism website founded by Nate Silver (initially began as a polling aggregation site, but now covers politics, sports, science and pop culture) and owned by ESPN...\" - fivethirtyeight Package</p> </li> <li> <p>Single Cell RNA-seq Data analysis with Seurat</p> </li> </ul>"},{"location":"day_1/D1.2_introR-R-and-RStudio/#what-is-rstudio","title":"What is RStudio?","text":"<p>RStudio is freely available open-source Integrated Development Environment (IDE). RStudio provides an environment with many features to make using R easier and is a great alternative to working on R in the terminal.</p> <p></p> <ul> <li>Graphical user interface, not just a command prompt</li> <li>Great learning tool</li> <li>Free for academic use</li> <li>Platform agnostic</li> <li>Open source</li> </ul>"},{"location":"day_1/D1.2_introR-R-and-RStudio/#creating-a-new-project-directory-in-rstudio","title":"Creating a new project directory in RStudio","text":"<p>Let's create a new project directory for our <code>Introduction to R</code> lesson today. </p> <ol> <li>Open RStudio.</li> <li>Go to the <code>File</code> menu and select <code>New Project</code>.</li> <li>In the <code>New Project</code> window, choose <code>New Directory</code>. Then, choose <code>New Project</code>. Name your new directory <code>Intro-to-R</code> and then \"Create the project as subdirectory of:\" the Desktop (or location of your choice).</li> <li>Click on <code>Create Project</code>.</li> </ol> <p> </p> <ol> <li>After your project is completed, if the project does not automatically open in RStudio, then go to the <code>File</code> menu, select <code>Open Project</code>, and choose <code>Intro-to-R.Rproj</code>.</li> <li>When RStudio opens, you will see three panels in the window.</li> <li>Go to the <code>File</code> menu and select <code>New File</code>, and select <code>R Script</code>.</li> <li>Go to the <code>File</code> menu and select <code>Save As...</code>, type <code>Intro-to-R.R</code> and select <code>Save</code>.</li> </ol> <p> </p> <p>The RStudio interface should now look like the screenshot below.</p> <p> </p>"},{"location":"day_1/D1.2_introR-R-and-RStudio/#what-is-a-project-in-rstudio","title":"What is a project in RStudio?","text":"<p>It is simply a directory that contains everything related your analyses for a specific project. RStudio projects are useful when you are working on context-specific analyses and you wish to keep them separate. When creating a project in RStudio you associate it with a working directory of your choice (either an existing one, or a new one). A <code>. RProj file</code> is created within that directory and that keeps track of your command history and variables in the environment. The <code>. RProj file</code> can be used to open the project in its current state but at a later date.</p> <p>When a project is (re)opened within RStudio the following actions are taken:</p> <ul> <li>A new R session (process) is started</li> <li>The .RData file in the project's main directory is loaded, populating the environment with any objects that were present when the project was closed. </li> <li>The .Rhistory file in the project's main directory is loaded into the RStudio History pane (and used for Console Up/Down arrow command history).</li> <li>The current working directory is set to the project directory.</li> <li>Previously edited source documents are restored into editor tabs</li> <li>Other RStudio settings (e.g. active tabs, splitter positions, etc.) are restored to where they were the last time the project was closed.</li> </ul> <p>Information adapted from RStudio Support Site</p>"},{"location":"day_1/D1.2_introR-R-and-RStudio/#rstudio-interface","title":"RStudio Interface","text":"<p>The RStudio interface has four main panels:</p> <ol> <li>Console: where you can type commands and see output. The console is all you would see if you ran R in the command line without RStudio.</li> <li>Script editor: where you can type out commands and save to file. You can also submit the commands to run in the console.</li> <li>Environment/History: environment shows all active objects and history keeps track of all commands run in console</li> <li>Files/Plots/Packages/Help</li> </ol>"},{"location":"day_1/D1.2_introR-R-and-RStudio/#organizing-and-setting-up-rstudio","title":"Organizing and Setting up RStudio","text":""},{"location":"day_1/D1.2_introR-R-and-RStudio/#viewing-your-working-directory","title":"Viewing your working directory","text":"<p>Before we organize our working directory, let's check to see where our current working directory is located by typing into the console:</p> <pre><code>getwd()\n</code></pre> <p>Your working directory should be the <code>Intro-to-R</code> folder constructed when you created the project. The working directory is where RStudio will automatically look for any files you bring in and where it will automatically save any files you create, unless otherwise specified.</p> <p>You can visualize your working directory by selecting the <code>Files</code> tab from the Files/Plots/Packages/Help window.</p> <p> </p> <p>If you wanted to choose a different directory to be your working directory, you could navigate to a different folder in the <code>Files</code> tab, then, click on the <code>More</code> dropdown menu which appears as a Cog and select <code>Set As Working Directory</code>.</p> <p> </p>"},{"location":"day_1/D1.2_introR-R-and-RStudio/#structuring-your-working-directory","title":"Structuring your working directory","text":"<p>To organize your working directory for a particular analysis, you should separate the original data (raw data) from intermediate datasets. For instance, you may want to create a <code>data/</code> directory within your working directory that stores the raw data, and have a <code>results/</code> directory for intermediate datasets and a <code>figures/</code> directory for the plots you will generate.</p> <p> </p> <p>Let's create these three directories within your working directory by clicking on <code>New Folder</code> within the <code>Files</code> tab. </p> <p>When finished, your working directory should look like:</p> <p> </p>"},{"location":"day_1/D1.2_introR-R-and-RStudio/#setting-up","title":"Setting up","text":"<p>This is more of a housekeeping task. We will be writing long lines of code in our script editor and want to make sure that the lines <code>wrap</code> and you don't have to scroll back and forth to look at your long line of code. </p> <p>Click on \"Code\" at the top of your RStudio screen and select \"Soft Wrap Long Lines\" in the pull down menu.</p> <p> </p>"},{"location":"day_1/D1.2_introR-R-and-RStudio/#interacting-with-r","title":"Interacting with R","text":"<p>Now that we have our interface and directory structure set up, let's start playing with R! There are two main ways of interacting with R in RStudio: using the console or by using script editor (plain text files that contain your code).</p>"},{"location":"day_1/D1.2_introR-R-and-RStudio/#console-window","title":"Console window","text":"<p>The console window (in RStudio, the bottom left panel) is the place where R is waiting for you to tell it what to do, and where it will show the results of a command.  You can type commands directly into the console, but they will be forgotten when you close the session. </p> <p>Let's test it out: <pre><code>3 + 5\n</code></pre> </p>"},{"location":"day_1/D1.2_introR-R-and-RStudio/#script-editor","title":"Script editor","text":"<p>Best practice is to enter the commands in the script editor, and save the script. You are encouraged to comment liberally to describe the commands you are running using <code>#</code>. This way, you have a complete record of what you did, you can easily show others how you did it and you can do it again later on if needed. </p> <p>Now let's try entering commands to the script editor and using the comments character <code>#</code> to add descriptions and run the code chunk.</p> <pre><code># Intro to R Lesson\n# Feb 16th, 2016\n# Interacting with R\n\n## I am adding 3 and 5. R is fun!\n3+5\n</code></pre> <p>The Rstudio script editor allows you to 'send' the current line or the currently highlighted text to the R console by clicking on the <code>Run</code> button in the upper-right hand corner of the script editor.</p> <p> </p> <p>Alternatively, you can run by simply pressing the <code>Ctrl</code> and <code>Return/Enter</code> keys at the same time as a shortcut.</p> <p> </p> <p>You should see the command run in the console and output the result.</p> <p>  | </p> <p>What happens if we do that same command without the comment symbol <code>#</code>? Re-run the command after removing the <code>#</code> sign in the front:</p> <pre><code>I am adding 3 and 5. R is fun!\n3+5\n</code></pre> <p>Error</p> <pre><code>Error: unexpected symbol in \"I am\"\n</code></pre> <p>Now R is trying to run that sentence as a command, and it  doesn't work. We get an error message in the console. It means the R interpreter did not know what to do with that command.</p>"},{"location":"day_1/D1.2_introR-R-and-RStudio/#console-command-prompt","title":"Console command prompt","text":"<p>Interpreting the command prompt can help understand when R is ready to accept commands. Below lists the different states of the command prompt and how you can exit a command:</p> Prompt/command Meaning Remarks <code>&gt;</code> Console is ready to accept commands When the console receives a command by directly typing into the console or running from the script editor Ctrl+Enter, R will try to execute it. <code>+</code> Console is waiting for you to enter more data It means that you haven't finished entering a complete command. Often this can be due to you having not 'closed' a parenthesis or quotation. ESC To escape the command and bring back a new prompt <code>&gt;</code> If you are in Rstudio and you can't figure out why your command isn't running, click inside the console window and press ESC"},{"location":"day_1/D1.2_introR-R-and-RStudio/#keyboard-shortcuts-in-rstudio","title":"Keyboard shortcuts in RStudio","text":"<p>In addition to some of the shortcuts described earlier in this lesson, we have listed a few more that can be helpful as you work in RStudio.</p> Key Action Ctrl+Enter Run command from script editor in console ESC Escape the current command to return to the command prompt Ctrl+1 Move cursor from console to script editor Ctrl+2 Move cursor from script editor to console Tab Use this key to complete a file path Ctrl+Shift+C Comment the block of highlighted text <p>Exercise</p> <p>Try highlighting only <code>3 +</code> from your script editor and running it. Find a way to bring back the command prompt <code>&gt;</code> in the console.</p>"},{"location":"day_1/D1.2_introR-R-and-RStudio/#the-r-syntax","title":"The R syntax","text":"<p>Now that we know how to talk with R via the script editor or the console, we want to use R for something more than adding numbers. To do this, we need to know more about the R syntax. </p> <p>The main parts of speech in R (syntax) include:</p> <ul> <li>The comments <code>#</code> and how they are used to document function and its content</li> <li>variables and functions</li> <li>The assignment operator <code>&lt;-</code></li> <li>the <code>=</code> for arguments in functions</li> </ul> <p>We will go through each of these parts of speech in more detail, starting with the assignment operator.</p> <p>Note</p> <p>Indentation and consistency in spacing is used to improve clarity and legibility.</p>"},{"location":"day_1/D1.2_introR-R-and-RStudio/#assignment-operator","title":"Assignment operator","text":"<p>To do useful and interesting things in R, we need to assign values to variables using the assignment operator, <code>&lt;-</code>.  For example, we can use the assignment operator to assign the value of <code>3</code> to <code>x</code> by executing:</p> <pre><code>x &lt;- 3\n</code></pre> <p>The assignment operator (<code>&lt;-</code>) assigns values on the right to variables on the left. </p> <p>Note</p> <p>In RStudio, typing Alt + - (push <code>Alt</code> at the same time as the <code>-</code> key), on Mac type option + - will write <code>&lt;-</code> in a single keystroke.</p>"},{"location":"day_1/D1.2_introR-R-and-RStudio/#variables","title":"Variables","text":"<p>A variable is a symbolic name for (or reference to) information. Variables in computer programming are analogous to \"buckets\", where information can be maintained and referenced. On the outside of the bucket is a name. When referring to the bucket, we use the name of the bucket, not the data stored in the bucket.</p> <p>In the example above, we created a variable or a 'bucket' called <code>x</code>. Inside we put a value, <code>3</code>. </p> <p>Let's create another variable called <code>y</code> and give it a value of 5. </p> <pre><code>y &lt;- 5\n</code></pre> <p>When assigning a value to an variable, R does not print anything to the console. You can force to print the value by using parentheses or by typing the variable name.</p> <pre><code>y\n</code></pre> <p>You can also view information on the variable by looking in your <code>Environment</code> window in the upper right-hand corner of the RStudio interface.</p> <p> </p> <p>Now we can reference these buckets by name to perform mathematical operations on the values contained within. What do you get in the console for the following operation: </p> <pre><code>x + y\n</code></pre> <p>Try assigning the results of this operation to another variable called <code>number</code>. </p> <pre><code>number &lt;- x + y\n</code></pre> <p>Exercise</p> <ol> <li>Try changing the value of the variable <code>x</code> to 5. What happens to <code>number</code>?</li> <li>Now try changing the value of variable <code>y</code> to contain the value 10. What do you need to do, to update the variable <code>number</code>?</li> </ol> <p>Tips on variable names</p> <p>Variables can be given almost any name, such as <code>x</code>, <code>current_temperature</code>, or <code>subject_id</code>. However, there are some rules / suggestions you should keep in mind:</p> <ul> <li>Make your names explicit and not too long.</li> <li>Avoid names starting with a number (<code>2x</code> is not valid but <code>x2</code> is)</li> <li>Avoid names of fundamental functions in R (e.g., <code>if</code>, <code>else</code>, <code>for</code>, see here for a complete list). In general, even if it's allowed, it's best to not use other function names (e.g., <code>c</code>, <code>T</code>, <code>mean</code>, <code>data</code>) as variable names. When in doubt check the help to see if the name is already in use. </li> <li>Avoid dots (<code>.</code>) within a variable name as in <code>my.dataset</code>. There are many functions in R with dots in their names for historical reasons, but because dots have a special meaning in R (for methods) and other programming languages, it's best to avoid them. </li> <li>Use nouns for object names and verbs for function names</li> <li>Keep in mind that R is case sensitive (e.g., <code>genome_length</code> is different from <code>Genome_length</code>)</li> <li>Be consistent with the styling of your code (where you put spaces, how you name variable, etc.). In R, two popular style guides are Hadley Wickham's style guide and Google's.</li> </ul>"},{"location":"day_1/D1.2_introR-R-and-RStudio/#interacting-with-data-in-r","title":"Interacting with data in R","text":"<p>R is commonly used for handling big data, and so it only makes sense that we learn about R in the context of some kind of relevant data. Let's take a few minutes to add files to the folders we created and familiarize ourselves with the data.</p>"},{"location":"day_1/D1.2_introR-R-and-RStudio/#adding-files-to-your-working-directory","title":"Adding files to your working directory","text":"<p>You can access the files we need for this workshop using the links provided below. If you right click on the link, and \"Save link as..\". Choose <code>~/Desktop/Intro-to-R/data</code> as the destination of the file. You should now see the file appear in your working directory. We will discuss these files a bit later in the lesson.</p> Data Download links Normalized count data Right click &amp; Save link as... Metadata file Right click &amp; Save link as... Functional analysis output Right click &amp; Save link as... <p>NOTE</p> <p>If the files download automatically to some other location on your laptop, you can move them to the your working directory using your file explorer or finder (outside RStudio), or navigating to the files in the <code>Files</code> tab of the bottom right panel of RStudio.</p>"},{"location":"day_1/D1.2_introR-R-and-RStudio/#about-the-dataset","title":"About the dataset","text":"<p>The count data </p> <p>In this example dataset, we have collected whole brain samples from 12 mice and want to evaluate expression differences between them. The expression data represents normalized count data obtained from RNA-sequencing of the 12 brain samples. This data is stored in a comma separated values (CSV) file as a 2-dimensional matrix, with each row corresponding to a gene and each column corresponding to a sample </p> <p> </p> <p>The metadata</p> <p> </p> <p>We have another file in which we identify information about the data or metadata. Our metadata is also stored in a CSV file. In this file, each row corresponds to a sample and each column contains some information about each sample.</p> <p>The first column contains the row names, and note that these are identical to the column names in our expression data file above (albeit, in a slightly different order). The next few columns contain information about our samples that allow us to categorize them. For example, the second column contains genotype information for each sample. Each sample is classified in one of two categories: Wt (wild type) or KO (knockout). What types of categories do you observe in the remaining columns?</p> <p>R is particularly good at handling this type of categorical data. Rather than simply storing this information as text, the data is represented in a specific data structure which allows the user to sort and manipulate the data in a quick and efficient manner. We will discuss this in more detail as we go through the different lessons in R! </p>"},{"location":"day_1/D1.2_introR-R-and-RStudio/#the-functional-analysis-results","title":"The functional analysis results","text":"<p>We will be using the results of the functional analysis to learn about packages/functions from the Tidyverse suite of integrated packages. These packages are designed to work together to make common data science operations like data wrangling, tidying, reading/writing, parsing, and visualizing, more user-friendly. </p>"},{"location":"day_1/D1.2_introR-R-and-RStudio/#best-practices","title":"Best practices","text":"<p>Before we move on to more complex concepts and getting familiar with the language, we want to point out a few things about best practices when working with R which will help you stay organized in the long run</p> <ul> <li> <p>Code and workflow are more reproducible if we can document everything that we do. Our end goal is not just to \"do stuff\", but to do it in a way that anyone can easily and exactly replicate our workflow and results. All code should be written in the script editor and saved to file, rather than working in the console.</p> </li> <li> <p>The R console should be mainly used to inspect objects, test a function or get help. </p> </li> <li> <p>Use <code>#</code> signs to comment. Comment liberally in your R scripts. This will help future you and other collaborators know what each line of code (or code block) was meant to do. Anything to the right of a <code>#</code> is ignored by R. A shortcut for this is Ctrl+Shift+C if you want to comment an entire chunk of text.</p> </li> </ul> <p>Attribution notice</p> <ul> <li> <p>This lesson has been developed by members of the teaching team at the Harvard Chan Bioinformatics Core (HBC). These are open access materials distributed under the terms of the Creative Commons Attribution license (CC BY 4.0), which permits unrestricted use, distribution, and reproduction in any medium, provided the original author and source are credited.</p> </li> <li> <p>The materials used in this lesson are adapted from work that is Copyright \u00a9 Data Carpentry (http://datacarpentry.org/).</p> </li> <li> <p>All Data Carpentry instructional material is made available under the Creative Commons Attribution license (CC BY 4.0).</p> </li> </ul>"},{"location":"day_1_exercise/D1.1e_r_syntax_and_data_structures/","title":"R Syntax and Data Structures","text":"<p>Approximate time: 70 min</p>"},{"location":"day_1_exercise/D1.1e_r_syntax_and_data_structures/#learning-objectives","title":"Learning Objectives","text":"<ul> <li>Describe frequently-used data types in R. </li> <li>Construct data structures to store data.</li> </ul>"},{"location":"day_1_exercise/D1.1e_r_syntax_and_data_structures/#data-types","title":"Data Types","text":"<p>Variables can contain values of specific types within R. The six data types that R uses include: </p> <ul> <li><code>\"numeric\"</code> for any numerical value, including whole numbers and decimals. This is the most common data type for performing mathematical operations.</li> <li><code>\"character\"</code> for text values, denoted by using quotes (\"\") around value. For instance, while 5 is a numeric value, if you were to put quotation marks around it, it would turn into a character value, and you could no longer use it for mathematical operations. Single or double quotes both work, as long as the same type is used at the beginning and end of the character value.</li> <li><code>\"integer\"</code> for whole numbers (e.g., <code>2L</code>, the <code>L</code> indicates to R that it's an integer). It behaves similar to the <code>numeric</code> data type for most tasks or functions; however, it takes up less storage space than numeric data, so often tools will output integers if the data is known to be comprised of whole numbers. Just know that integers behave similarly to numeric values. If you wanted to create your own, you could do so by providing the whole number, followed by an upper-case L.</li> <li><code>\"logical\"</code> for <code>TRUE</code> and <code>FALSE</code> (the Boolean data type). The <code>logical</code> data type can be specified using four values, <code>TRUE</code> in all capital letters, <code>FALSE</code> in all capital letters, a single capital <code>T</code> or a single capital <code>F</code>.</li> <li><code>\"complex\"</code> to represent complex numbers with real and imaginary parts (e.g.,   <code>1+4i</code>) and that's all we're going to say about them</li> <li><code>\"raw\"</code> that we won't discuss further</li> </ul> <p>The table below provides examples of each of the commonly used data types:</p> Data Type Examples Numeric: 1, 1.5, 20, pi Character: \u201canytext\u201d, \u201c5\u201d, \u201cTRUE\u201d Integer: 2L, 500L, -17L Logical: TRUE, FALSE, T, F <p>The type of data will determine what you can do with it. For example, if you want to perform mathematical operations, then your data type cannot be character or logical. Whereas if you want to search for a word or pattern in your data, then you data should be of the character data type. The task or function being performed on the data will determine what type of data can be used. </p>"},{"location":"day_1_exercise/D1.1e_r_syntax_and_data_structures/#data-structures","title":"Data Structures","text":"<p>We know that variables are like buckets, and so far we have seen that bucket filled with a single value. Even when <code>number</code> was created, the result of the mathematical operation was a single value. Variables can store more than just a single value, they can store a multitude of different data structures. These include, but are not limited to, vectors (<code>c</code>), factors (<code>factor</code>), matrices (<code>matrix</code>), data frames (<code>data.frame</code>) and lists (<code>list</code>).</p>"},{"location":"day_1_exercise/D1.1e_r_syntax_and_data_structures/#vectors","title":"Vectors","text":"<p>A vector is the most common and basic data structure in R, and is pretty much the workhorse of R. It's basically just a collection of values, mainly either numbers,</p> <p> <p>or characters,</p> <p></p> <p>or logical values,</p> <p></p> <p></p> <p>Note</p> <p>All values in a vector must be of the same data type. </p> <p>If you try to create a vector with more than a single data type, R will try to coerce it into a single data type. </p> <p>For example, if you were to try to create the following vector:</p> <p> <p> R will coerce it into:</p> <p>  The analogy for a vector is that your bucket now has different compartments; these compartments in a vector are called elements. </p> <p>Each element contains a single value, and there is no limit to how many elements you can have. A vector is assigned to a single variable, because regardless of how many elements it contains, in the end it is still a single entity (bucket). </p> <p>Let's create a vector of genome lengths and assign it to a variable called <code>glengths</code>. </p> <p>Each element of this vector contains a single numeric value, and three values will be combined together into a vector using <code>c()</code> (the combine function). All of the values are put within the parentheses and separated with a comma.</p> <pre><code># Create a numeric vector and store the vector as a variable called 'glengths'\nglengths &lt;- c(4.6, 3000, 50000)\nglengths\n</code></pre> <p>Note</p> <p>Your environment shows the <code>glengths</code> variable is numeric (num) and tells you the <code>glengths</code> vector starts at element 1 and ends at element 3 (i.e. your vector contains 3 values) as denoted by the [1:3].*</p> <p>A vector can also contain characters. Create another vector called <code>species</code> with three elements, where each element corresponds with the genome sizes vector (in Mb).</p> <p><pre><code># Create a character vector and store the vector as a variable called 'species'\nspecies &lt;- c(\"ecoli\", \"human\", \"corn\")\nspecies\n</code></pre> What do you think would happen if we forgot to put quotations around one of the values? Let's test it out with corn.</p> <p><pre><code># Forget to put quotes around corn\nspecies &lt;- c(\"ecoli\", \"human\", corn)\n</code></pre> Note that RStudio is quite helpful in color-coding the various data types. We can see that our numeric values are blue, the character values are green, and if we forget to surround corn with quotes, it's black. What does this mean? Let's try to run this code.</p> <p>When we try to run this code we get an error specifying that object 'corn' is not found. What this means is that R is looking for an object or variable in my Environment called 'corn', and when it doesn't find it, it returns an error. If we had a character vector called 'corn' in our Environment, then it would combine the contents of the 'corn' vector with the values \"ecoli\" and \"human\".</p> <p>Since we only want to add the value \"corn\" to our vector, we need to re-run the code with the quotation marks surrounding corn. A quick way to add quotes to both ends of a word in RStudio is to highlight the word, then press the quote key.</p> <pre><code># Create a character vector and store the vector as a variable called 'species'\nspecies &lt;- c(\"ecoli\", \"human\", \"corn\")\n</code></pre> <p>Exercise</p> <p>Try to create a vector of numeric and character values by combining the two vectors that we just created (<code>glengths</code> and <code>species</code>). Assign this combined vector to a new variable called <code>combined</code>. Hint: you will need to use the combine <code>c()</code> function to do this. </p> <p>Print the <code>combined</code> vector in the console, what looks different compared to the original vectors?</p>"},{"location":"day_1_exercise/D1.1e_r_syntax_and_data_structures/#factors","title":"Factors","text":"<p>A factor is a special type of vector that is used to store categorical data. Each unique category is referred to as a factor level (i.e. category = level). Factors are built on top of integer vectors such that each factor level is assigned an integer value, creating value-label pairs. </p> <p>For instance, if we have four animals and the first animal is female, the second and third are male, and the fourth is female, we could create a factor that appears like a vector, but has integer values stored under-the-hood. The integer value assigned is a one for females and a two for males. The numbers are assigned in alphabetical order, so because the f- in females comes before the m- in males in the alphabet, females get assigned a one and males a two. In later lessons we will show you how you could change these assignments.</p> <p> </p> <p>Let's create a factor vector and explore a bit more.  We'll start by creating a character vector describing three different levels of expression. Perhaps the first value represents expression in mouse1, the second value represents expression in mouse2, and so on and so forth:</p> <pre><code># Create a character vector and store the vector as a variable called 'expression'\nexpression &lt;- c(\"low\", \"high\", \"medium\", \"high\", \"low\", \"medium\", \"high\")\n</code></pre> <p>Now we can convert this character vector into a factor using the <code>factor()</code> function:</p> <pre><code># Turn 'expression' vector into a factor\nexpression &lt;- factor(expression)\n</code></pre> <p>So, what exactly happened when we applied the <code>factor()</code> function? </p> <p> </p> <p>The expression vector is categorical, in that all the values in the vector belong to a set of categories; in this case, the categories are <code>low</code>, <code>medium</code>, and <code>high</code>. By turning the expression vector into a factor, the categories are assigned integers alphabetically, with high=1, low=2, medium=3. This in effect assigns the different factor levels. You can view the newly created factor variable and the levels in the Environment window.</p> <p> </p> <p>So now that we have an idea of what factors are, when would you ever want to use them?</p> <p>Factors are extremely valuable for many operations often performed in R. For instance, factors can give order to values with no intrinsic order. In the previous 'expression' vector, if I wanted the low category to be less than the medium category, then we could do this using factors. Also, factors are necessary for many statistical methods. For example, descriptive statistics can be obtained for character vectors if you have the categorical information stored as a factor. Also, if you want to denote which category is your base level for a statistical comparison, then you would need to have your category variable stored as a factor with the base level assigned to 1. Anytime that it is helpful to have the categories thought of as groups in an analysis, the factor function makes this possible. For instance, if you want to color your plots by treatment type, then you would need the treatment variable to be a factor.</p> <p>Exercises</p> <p>Let's say that in our experimental analyses, we are working with three different sets of cells: normal, cells knocked out for geneA (a very exciting gene), and cells overexpressing geneA. We have three replicates for each celltype.</p> <ol> <li> <p>Create a vector named <code>samplegroup</code> with nine elements: 3 control (\"CTL\") values, 3 knock-out (\"KO\") values, and 3 over-expressing (\"OE\") values.</p> </li> <li> <p>Turn <code>samplegroup</code> into a factor data structure.</p> </li> </ol>"},{"location":"day_1_exercise/D1.1e_r_syntax_and_data_structures/#matrix","title":"Matrix","text":"<p>A <code>matrix</code> in R is a collection of vectors of same length and identical datatype. Vectors can be combined as columns in the matrix or by row, to create a 2-dimensional structure.</p> <p> </p> <p>Matrices are used commonly as part of the mathematical machinery of statistics. They are usually of numeric datatype and used in computational algorithms to serve as a checkpoint. For example, if input data is not of identical data type (numeric, character, etc.), the <code>matrix()</code> function will throw an error and stop any downstream code execution.</p>"},{"location":"day_1_exercise/D1.1e_r_syntax_and_data_structures/#data-frame","title":"Data Frame","text":"<p>A <code>data.frame</code> is the de facto data structure for most tabular data and what we use for statistics and plotting. A <code>data.frame</code> is similar to a matrix in that it's a collection of vectors of the same length and each vector represents a column. However, in a dataframe each vector can be of a different data type (e.g., characters, integers, factors). In the data frame pictured below, the first column is character, the second column is numeric, the third is character, and the fourth is logical.</p> <p> </p> <p>A data frame is the most common way of storing data in R, and if used systematically makes data analysis easier. </p> <p>We can create a dataframe by bringing vectors together to form the columns. We do this using the <code>data.frame()</code> function, and giving the function the different vectors we would like to bind together. This function will only work for vectors of the same length.</p> <pre><code># Create a data frame and store it as a variable called 'df'\ndf &lt;- data.frame(species, glengths)\n</code></pre> <p>We can see that a new variable called <code>df</code> has been created in our <code>Environment</code> within a new section called <code>Data</code>. In the <code>Environment</code>, it specifies that <code>df</code> has 3 observations of 2 variables. What does that mean? In R, rows always come first, so it means that <code>df</code> has 3 rows and 2 columns. We can get additional information if we click on the blue circle with the white triangle in the middle next to <code>df</code>. It will display information about each of the columns in the data frame, giving information about what the data type is of each of the columns and the first few values of those columns.</p> <p>Another handy feature in RStudio is that if we hover the cursor over the variable name in the <code>Environment</code>, <code>df</code>, it will turn into a pointing finger. If you click on <code>df</code>, it will open the data frame as it's own tab next to the script editor. We can explore the table interactively within this window. To close, just click on the X on the tab.</p> <p>As with any variable, we can print the values stored inside to the console if we type the variable's name and run. </p> <pre><code>df\n</code></pre> <p>Exercise</p> <p>Create a data frame called <code>favorite_books</code> with the following vectors as columns:</p> <pre><code>titles &lt;- c(\"Catch-22\", \"Pride and Prejudice\", \"Nineteen Eighty Four\")\npages &lt;- c(453, 432, 328)\n</code></pre>"},{"location":"day_1_exercise/D1.1e_r_syntax_and_data_structures/#lists","title":"Lists","text":"<p>Lists are a data structure in R that can be perhaps a bit daunting at first, but soon become amazingly useful. A list is a data structure that can hold any number of any types of other data structures.</p> <p> </p> <p>If you have variables of different data structures you wish to combine, you can put all of those into one list object by using the <code>list()</code> function and placing all the items you wish to combine within parentheses:</p> <pre><code>list1 &lt;- list(species, df, number)\n</code></pre> <p>We see <code>list1</code> appear within the Data section of our environment as a list of 3 components or variables. If we click on the blue circle with a triangle in the middle, it's not quite as interpretable as it was for data frames. </p> <p>Essentially, each component is preceded by a colon. The first colon give the <code>species</code> vector, the second colon precedes the <code>df</code> data frame, with the dollar signs indicating the different columns, the last colon gives the single value, <code>number</code>.</p> <p>If I click on <code>list1</code>, it opens a tab where you can explore the contents a bit more, but it's still not super intuitive. The easiest way to view small lists is to print to the console. </p> <p>Let's type list1 and print to the console by running it.</p> <pre><code>list1\n\n[[1]]\n[1] \"ecoli\" \"human\" \"corn\" \n\n[[2]]\n  species glengths\n1   ecoli      4.6\n2   human   3000.0\n3    corn  50000.0\n\n[[3]]\n[1] 5\n</code></pre> <p>There are three components corresponding to the three different variables we passed in, and what you see is that structure of each is retained. Each component of a list is referenced based on the number position. We will talk more about how to inspect and manipulate components of lists in later lessons.</p> <p>Exercise</p> <p>Create a list called <code>list2</code> containing <code>species</code>, <code>glengths</code>, and <code>number</code>.</p> <p>Now that we know what lists are, why would we ever want to use them? When getting started with R, you will most likely encounter lists with different tools or functions that you use. Oftentimes a tool will need a list as input, so that all the information needed to run the tool is present in a single variable. Sometimes a tool will output a list when working through an analysis. Knowing how to work with them and extract necessary information will be critically important. </p> <p>As you become more comfortable with R, you will find yourself using lists more often. One common use of lists is to make iterative processes more efficient. For example, let's say you had multiple data frames containing the same weather information from different cities throughout North America. You wanted to perform the same task on each of the data frames, but that would take a long time to do individually. Instead you could create a list where each data frame is a component of the list. Then, you could perform the task on the list instead, which would be applied to each of the components.</p> <p>Attribution notice</p> <ul> <li> <p>This lesson has been developed by members of the teaching team at the Harvard Chan Bioinformatics Core (HBC). These are open access materials distributed under the terms of the Creative Commons Attribution license (CC BY 4.0), which permits unrestricted use, distribution, and reproduction in any medium, provided the original author and source are credited.</p> </li> <li> <p>The materials used in this lesson are adapted from work that is Copyright \u00a9 Data Carpentry (http://datacarpentry.org/).</p> </li> <li> <p>All Data Carpentry instructional material is made available under the Creative Commons Attribution license (CC BY 4.0).</p> </li> </ul>"},{"location":"day_1_exercise/D1.2e_functions_and_arguments/","title":"Functions in R","text":"<p>Approximate time: 30 min</p>"},{"location":"day_1_exercise/D1.2e_functions_and_arguments/#learning-objectives","title":"Learning Objectives","text":"<ul> <li>Describe and utilize functions in R. </li> <li>Modify default behavior of a function using arguments.</li> <li>Identify R-specific sources of obtaining more information about functions.</li> <li>Demonstrate how to create user-defined functions in R</li> </ul>"},{"location":"day_1_exercise/D1.2e_functions_and_arguments/#functions-and-their-arguments","title":"Functions and their arguments","text":""},{"location":"day_1_exercise/D1.2e_functions_and_arguments/#what-are-functions","title":"What are functions?","text":"<p>A key feature of R is functions. Functions are \"self contained\" modules of code that accomplish a specific task. Functions usually take in some sort of data structure (value, vector, dataframe etc.), process it, and return a result.</p> <p>The general usage for a function is the name of the function followed by parentheses:</p> <p><pre><code>function_name(input)\n</code></pre> The input(s) are called arguments, which can include:</p> <ol> <li>the physical object (any data structure) on which the function carries out a task </li> <li>specifications that alter the way the function operates (e.g. options)</li> </ol> <p>Not all functions take arguments, for example:</p> <pre><code>getwd()\n</code></pre> <p>However, most functions can take several arguments. If you don't specify a required argument when calling the function, you will either receive an error or the function will fall back on using a default. </p> <p>The defaults represent standard values that the author of the function specified as being \"good enough in standard cases\". An example would be what symbol to use in a plot. However, if you want something specific, simply change the argument yourself with a value of your choice.</p>"},{"location":"day_1_exercise/D1.2e_functions_and_arguments/#basic-functions","title":"Basic functions","text":"<p>We have already used a few examples of basic functions in the previous lessons i.e <code>getwd()</code>, <code>c()</code>, and  <code>factor()</code>. These functions are available as part of R's built in capabilities, and we will explore a few more of these base functions below. </p> <p>Let's revisit a function that we have used previously to combine data <code>c()</code> into vectors. The arguments it takes is a collection of numbers, characters or strings (separated by a comma). The <code>c()</code> function performs the task of combining the numbers or characters into a single vector. You can also use the function to add elements to an existing vector:</p> <pre><code>glengths &lt;- c(glengths, 90) # adding at the end \nglengths &lt;- c(30, glengths) # adding at the beginning\n</code></pre> <p>What happens here is that we take the original vector <code>glengths</code> (containing three elements), and we are adding another item to either end. We can do this over and over again to build a vector or a dataset.</p> <p>Since R is used for statistical computing, many of the base functions involve mathematical operations. One example would be the function <code>sqrt()</code>. The input/argument must be a number, and the output is the square root of that number. Let's try finding the square root of 81:</p> <pre><code>sqrt(81)\n</code></pre> <p>Now what would happen if we called the function (e.g. ran the function), on a vector of values instead of a single value? </p> <pre><code>sqrt(glengths)\n</code></pre> <p>In this case the task was performed on each individual value of the vector <code>glengths</code> and the respective results were displayed.</p> <p>Let's try another function, this time using one that we can change some of the options (arguments that change the behavior of the function), for example <code>round</code>:</p> <pre><code>round(3.14159)\n</code></pre> <p>We can see that we get <code>3</code>. That's because the default is to round to the nearest whole number. What if we want a different number of significant digits? Let's first learn how to find available arguments for a function.</p>"},{"location":"day_1_exercise/D1.2e_functions_and_arguments/#seeking-help-on-arguments-for-functions","title":"Seeking help on arguments for functions","text":"<p>The best way of finding out this information is to use the <code>?</code> followed by the name of the function. Doing this will open up the help manual in the bottom right panel of RStudio that will provide a description of the function, usage, arguments, details, and examples: </p> <pre><code>?round\n</code></pre> <p>Alternatively, if you are familiar with the function but just need to remind yourself of the names of the arguments, you can use:</p> <pre><code>args(round)\n</code></pre> <p>Even more useful is the <code>example()</code> function. This will allow you to run the examples section from the Online Help to see exactly how it works when executing the commands. Let's try that for <code>round()</code>:</p> <pre><code>example(\"round\")\n</code></pre> <p>In our example, we can change the number of digits returned by adding an argument. We can type <code>digits=2</code> or however many we may want:</p> <pre><code>round(3.14159, digits=2)\n</code></pre> <p>Note</p> <p>If you provide the arguments in the exact same order as they are defined (in the help manual) you don't have to name them:</p> <p><pre><code>round(3.14159, 2)\n</code></pre> However, it's usually not recommended practice because it involves a lot of memorization. In addition, it makes your code difficult to read for your future self and others, especially if your code includes functions that are not commonly used. (It's however OK to not include the names of the arguments for basic functions like <code>mean</code>, <code>min</code>, etc...). Another advantage of naming arguments, is that the order doesn't matter. This is useful when a function has many arguments. </p> <p>Exercise</p> <ol> <li> <p>Let's use base R function to calculate mean value of the <code>glengths</code> vector. You might need to search online to find what function can perform this task.</p> </li> <li> <p>Create a new vector <code>test &lt;- c(1, NA, 2, 3, NA, 4)</code>. Use the same base R function from exercise 1 (with addition of proper argument), and calculate mean value of the <code>test</code> vector. The output should be <code>2.5</code>.</p> <p>NOTE: In R, missing values are represented by the symbol <code>NA</code> (not available). It\u2019s a way to make sure that users know they have missing data, and make a conscious decision on how to deal with it. There are ways to ignore <code>NA</code> during statistical calculation, or to remove <code>NA</code> from the vector. If you want more information related to missing data or <code>NA</code> you can go to this page (please note that there are many advanced concepts on that page that have not been covered in class).</p> </li> <li>Another commonly used base function is <code>sort()</code>. Use this function to sort the <code>glengths</code> vector in descending order.</li> </ol>"},{"location":"day_1_exercise/D1.2e_functions_and_arguments/#user-defined-functions","title":"User-defined Functions","text":"<p>One of the great strengths of R is the user's ability to add functions. Sometimes there is a small task (or series of tasks) you need done and you find yourself having to repeat it multiple times. In these types of situations, it can be helpful to create your own custom function. The structure of a function is given below:</p> <pre><code>name_of_function &lt;- function(argument1, argument2) {\n    statements or code that does something\n    return(something)\n}\n</code></pre> <ul> <li>First you give your function a name. </li> <li>Then you assign value to it, where the value is the function. </li> </ul> <p>When defining the function you will want to provide the list of arguments required (inputs and/or options to modify behaviour of the function), and wrapped between curly brackets place the tasks that are being executed on/using those arguments.  The argument(s) can be any type of object (like a scalar, a matrix, a dataframe, a vector, a logical, etc), and it\u2019s not necessary to define what it is in any way. </p> <p>Finally, you can \u201creturn\u201d the value of the object from the function, meaning pass the value of it into the global environment. The important idea behind functions is that objects that are created within the function are local to the environment of the function \u2013 they don\u2019t exist outside of the function. </p> <p>Let's try creating a simple example function. This function will take in a numeric value as input, and return the squared value.</p> <pre><code>square_it &lt;- function(x) {\n    square &lt;- x * x\n    return(square)\n}\n</code></pre> <p>Once you run the code, you should see a function named <code>square_it</code> in the Environment panel (located at the top right of Rstudio interface). Now, we can use this function as any other base R functions. We type out the name of the function, and inside the parentheses  we provide a numeric value <code>x</code>:</p> <pre><code>square_it(5)\n</code></pre> <p>Pretty simple, right? In this case, we only had one line of code that was run, but in theory you could have many lines of code to get obtain the final results that you want to \"return\" to the user. </p> <p>Do I always have to <code>return()</code> something at the end of the function?</p> <p>In the example above, we created a new variable called <code>square</code> inside the function, and then return the value of <code>square</code>. If you don't use <code>return()</code>, by default R will return the value of the last line of code inside that function. That is to say, the following function will also work. </p> <p><pre><code>square_it &lt;- function(x) {\n    x * x\n}\n</code></pre> However, we recommend always using <code>return</code> at the end of a function as the best practice.</p> <p>We have only scratched the surface here when it comes to creating functions! We will revisit this in later lessons, but if interested you can also find more detailed information on this R-bloggers site, which is where we adapted this example from.</p> <p>Exercise</p> <ol> <li>Write a function called <code>multiply_it</code>, which takes two inputs: a numeric value <code>x</code>, and a numeric value <code>y</code>. The function will return the product of these two numeric values, which is <code>x * y</code>. For example, <code>multiply_it(x=4, y=6)</code> will return output <code>24</code>.</li> </ol> <p>Attribution notice</p> <p>This lesson has been developed by members of the teaching team at the Harvard Chan Bioinformatics Core (HBC). These are open access materials distributed under the terms of the Creative Commons Attribution license (CC BY 4.0), which permits unrestricted use, distribution, and reproduction in any medium, provided the original author and source are credited.</p> <ul> <li>The materials used in this lesson are adapted from work that is Copyright \u00a9 Data Carpentry (http://datacarpentry.org/). All Data Carpentry instructional material is made available under the Creative Commons Attribution license (CC BY 4.0).</li> </ul>"},{"location":"day_1_exercise/D1.3e_reading_in_and_data_inspection/","title":"Reading in and inspecting data","text":""},{"location":"day_1_exercise/D1.3e_reading_in_and_data_inspection/#learning-objectives","title":"Learning Objectives","text":"<ul> <li>Demonstrate how to read existing data into R</li> <li>Utilize base R functions to inspect data structures</li> </ul>"},{"location":"day_1_exercise/D1.3e_reading_in_and_data_inspection/#reading-data-into-r","title":"Reading data into R","text":""},{"location":"day_1_exercise/D1.3e_reading_in_and_data_inspection/#the-basics","title":"The basics","text":"<p>Regardless of the specific analysis in R we are performing, we usually need to bring data in for any analysis being done in R, so learning how to read in data is a crucial component of learning to use R.</p> <p>Many functions exist to read data in, and the function in R you use will depend on the file format being read in. Below we have a table with some examples of functions that can be used for importing some common text data types (plain text).</p> <p> Data type Extension Function Package Comma separated values csv <code>read.csv()</code> utils (default) <code>read_csv()</code> readr (tidyverse) Tab separated values tsv <code>read_tsv()</code> readr Other delimited formats txt <code>read.table()</code> utils <code>read_table()</code> readr <code>read_delim()</code> readr <p></p> <p>For example, if we have text file where the columns are separated by commas (comma-separated values or comma-delimited), you could use the function <code>read.csv</code>. However, if the data are separated by a different delimiter in a text file (e.g. \":\", \";\", \" \", \"\\t\"), you could use the generic <code>read.table</code> function and specify the delimiter (<code>sep = \" \"</code>) as an argument in the function. </p> <p>Note: The <code>\"\\t\"</code> delimiter is shorthand for tab.</p> <p>In the above table we refer to base R functions as being contained in the \"utils\" package. In addition to base R functions, we have also listed functions from some other packages that can be used to import data, specifically the \"readr\" package that installs when you install the \"tidyverse\" suite of packages.</p> <p>In addition to plain text files, you can also import data from other statistical analysis packages and Excel using functions from different packages. </p> <p> Data type Extension Function Package Stata version 13-14 dta <code>readdta()</code> haven Stata version 7-12 dta <code>read.dta()</code> foreign SPSS sav <code>read.spss()</code> foreign SAS sas7bdat <code>read.sas7bdat()</code> sas7bdat Excel xlsx, xls <code>read_excel()</code> readxl (tidyverse) <p></p> <p>Note</p> <p>These lists are not comprehensive, and may other functions exist for importing data. Once you have been using R for a bit, maybe you will have a preference for which functions you prefer to use for which data type.</p>"},{"location":"day_1_exercise/D1.3e_reading_in_and_data_inspection/#metadata","title":"Metadata","text":"<p>When working with large datasets, you will very likely be working with \"metadata\" file which contains the information about each sample in your dataset.</p> <p> <p> The metadata is very important information and we encourage you to think about creating a document with as much metadata you can record before you bring the data into R. Here is some additional reading on metadata from the HMS Data Management Working Group.</p>"},{"location":"day_1_exercise/D1.3e_reading_in_and_data_inspection/#the-readcsv-function","title":"The <code>read.csv()</code> function","text":"<p>Let's bring in the metadata file we downloaded earlier (<code>mouse_exp_design.csv</code> or <code>mouse_exp_design.txt</code>) using the <code>read.csv</code> function. </p> <p>First, check the arguments for the function using the <code>?</code> to ensure that you are entering all the information appropriately:</p> <p><pre><code>?read.csv\n</code></pre> <p></p> <p>The first thing you will notice is that you've pulled up the documentation for <code>read.table()</code>, this is because that is the parent function and all the other functions are in the same family. </p> <p>The next item on the documentation page is the function Description, which specifies that the output of this set of functions is going to be a data frame - \"Reads a file in table format and creates a data frame from it, with cases corresponding to lines and variables to fields in the file.\"</p> <p>In usage, all of the arguments listed for <code>read.table()</code> are the default values for all of the family members unless otherwise specified for a given function. Let's take a look at 2 examples:</p> <ol> <li> <p>The separator </p> <ul> <li>in the case of <code>read.table()</code> it is <code>sep = \"\"</code> (space or tab)</li> <li>whereas for <code>read.csv()</code> it is <code>sep = \",\"</code> (a comma).</li> </ul> </li> <li> <p>The <code>header</code> </p> <p>This argument refers to the column headers that may (<code>TRUE</code>) or may not (<code>FALSE</code>) exist in the plain text file you are reading in. </p> <ul> <li>in the case of <code>read.table()</code> it is <code>header = FALSE</code> (by default, it assumes you do not have column names)</li> <li>whereas for <code>read.csv()</code> it is <code>header = TRUE</code> (by default, it assumes that all your columns have names listed). </li> </ul> </li> </ol> <p>The take-home from the \"Usage\" section for <code>read.csv()</code> is that it has one mandatory argument, the path to the file and filename in quotations; in our case that is <code>data/mouse_exp_design.csv</code> or <code>data/mouse_exp_design.txt</code>.</p> <p>The <code>stringsAsFactors</code> argument</p> <p>Note that the <code>read.table {utils}</code> family of functions has an argument called <code>stringsAsFactors</code>, which by default is set to FALSE (you can double check this by searching the Help tab for <code>read.table</code> or running <code>?read.table</code> in the console).</p> <p>If <code>stringsAsFactors = TRUE</code>, any function in this family of functions will coerce <code>character</code> columns in the data you are reading in to <code>factor</code> columns (i.e., coerce from <code>vector</code> to <code>factor</code>) in the resulting data frame.  </p> <p>If you want to maintain the <code>character vector</code> data structure (e.g., for gene names), you will want to make sure that <code>stringsAsFactors = FALSE</code>.</p>"},{"location":"day_1_exercise/D1.3e_reading_in_and_data_inspection/#create-a-data-frame-by-reading-in-the-file","title":"Create a data frame by reading in the file","text":"<p>At this point, please check the extension for the <code>mouse_exp_design</code> file within your <code>data</code> folder. You will have to type it accordingly within the <code>read.csv()</code> function.</p> <p>Note</p> <p><code>read.csv</code> is not fussy about extensions for plain text files, so even though the file we are reading in is a comma-separated value file, it will be read in properly even with a <code>.txt</code> extension.</p> <p>Let's read in the <code>mouse_exp_design</code> file and create a new data frame called <code>metadata</code>.</p> <pre><code>metadata &lt;- read.csv(file=\"data/mouse_exp_design.csv\")\n\n# OR \n# metadata &lt;- read.csv(file=\"data/mouse_exp_design.txt\")\n</code></pre> <p>NOTE</p> <p>RStudio supports the automatic completion of code using the Tab key. This is especially helpful for when reading in files to ensure the correct file path. The tab completion feature also provides a shortcut to listing objects, and inline help for functions. Tab completion is your friend! We encourage you to use it whenever possible.</p> Click here to see how to import data using the Import Dataset <p>You can also use the Import Dataset button in your Environment pane to import data. This option is not as appealing because it can lack reproducibility if not documented properly, but it can be helpful when getting started. In order to use the Import Dataset</p> <ol> <li>Left-click the Import Dataset button in the Environment pane</li> <li>Left-click From Text (base...)</li> <li>Navigate to the file you would like to import and select Open</li> <li>Type the name you would like the imported object to be called in the <code>Name</code> textbox.</li> <li>Select the delimiter that your file is using in the <code>Separator</code> dropdown menu</li> <li>Left-click Import</li> </ol> <p>These steps are summarized in the GIF below:</p> <p> </p> <p>Now the dataset has been imported into your environment.</p> <p>Note</p> <p>If you are going to use this method, it could impact the reproducibility of your work, because the steps to do that import are not recorded anywhere. If you are going to use this method of importing data, it is STRONGLY RECOMMENDED that you copy the command that read the dataset in and is present in the console to an Rscript file. In the future, you can run that line of code from the Rscript file to recreate the data object.</p> <p>Go to your Global environment and click on the name of the data frame you just created. </p> <p> </p> <p>When you do this the metadata table will pop up on the top left hand corner of RStudio, right next to the R script.</p> <p> </p> <p>You should see a subtle coloring (blue-gray) of the first row and first column, the rest of the table will have a white background. This is because your first row and first columns have different properties than the rest of the table, they are the names of the rows and columns respectively. </p> <p> </p> <p>Earlier we noted that the file we just read in had column names (first row of values) and how <code>read.csv()</code> deals with \"headers\". In addition to column headers, <code>read.csv()</code> also assumes that the first column contains the row names. Not all functions in the <code>read.table()</code> family of functions will do this and depending on which one you use, you may have to specify an additional argument to properly assign the row names and column names.</p> <p>Note</p> <p>Row names and column names are really handy when subsetting data structures and they are also helpful to identify samples or genes. We almost always use them with data frames.</p> <p>Exercise 1</p> <ol> <li>Download this tab-delimited <code>.txt</code> file and save it in your  project's <code>data</code> folder.</li> <li>Read it in to R using <code>read.table()</code> with the approriate arguments and store it as the variable <code>proj_summary</code>. To figure out the appropriate arguments to use with <code>read.table()</code>, keep the following in mind:<ul> <li>all the columns in the input text file have column name/headers</li> <li>you want the first column of the text file to be used as row names (hint: look up the input for the <code>row.names =</code> argument in <code>read.table()</code>)</li> </ul> </li> <li>Display the contents of <code>proj_summary</code> in your console</li> </ol>"},{"location":"day_1_exercise/D1.3e_reading_in_and_data_inspection/#inspecting-data-structures","title":"Inspecting data structures","text":"<p>There are a wide selection of base functions in R that are useful for inspecting your data and summarizing it. Let's use the <code>metadata</code> file that we created to test out data inspection functions. </p> <p>Take a look at the dataframe by typing out the variable name <code>metadata</code> and pressing return; the variable contains information describing the samples in our study. Each row holds information for a single sample, and the columns contain categorical information about the sample <code>genotype</code>(WT or KO),  <code>celltype</code> (typeA or typeB), and <code>replicate number</code> (1,2, or 3).</p> <pre><code>metadata\n</code></pre> <p>Output</p> <pre><code>genotype celltype replicate\nsample1        Wt    typeA      1\nsample2        Wt    typeA      2\nsample3        Wt    typeA      3\nsample4        KO    typeA      1\nsample5        KO    typeA      2\nsample6        KO    typeA      3\nsample7        Wt    typeB      1\nsample8        Wt    typeB      2\nsample9        Wt    typeB      3\nsample10       KO    typeB      1\nsample11       KO    typeB      2\nsample12       KO    typeB      3\n</code></pre> <p>Suppose we had a larger file, we might not want to display all the contents in the console. Instead we could check the top (the first 6 lines) of this <code>data.frame</code> using the function <code>head()</code>:</p> <pre><code>head(metadata)\n</code></pre>"},{"location":"day_1_exercise/D1.3e_reading_in_and_data_inspection/#list-of-functions-for-data-inspection","title":"List of functions for data inspection","text":"<p>We already saw how the functions <code>head()</code> and <code>str()</code> (in the releveling section) can be useful to check the content and the structure of a <code>data.frame</code>. Below is a non-exhaustive list of functions to get a sense of the content/structure of data. The list has been divided into functions that work on all types of objects, some that work only on vectors/factors (1 dimensional objects), and others that work on data frames and matrices (2 dimensional objects).</p> <p>We have some exercises below that will allow you to gain more familiarity with these. You will definitely be using some of them in the next few homework sections.</p> <ul> <li> <p>All data structures - content display:</p> <ul> <li><code>str()</code>: compact display of data contents (similar to what you see in the Global environment)</li> <li><code>class()</code>: displays the data type for vectors (e.g. character, numeric, etc.) and data structure for dataframes, matrices, lists</li> <li><code>summary()</code>: detailed display of the contents of a given object, including descriptive statistics, frequencies</li> <li><code>head()</code>:  prints the first 6 entries (elements for 1-D objects, rows for 2-D objects)</li> <li><code>tail()</code>: prints the last 6 entries (elements for 1-D objects, rows for 2-D objects)</li> </ul> </li> <li> <p>Vector and factor variables: </p> <ul> <li><code>length()</code>: returns the number of elements in a vector or factor</li> </ul> </li> <li> <p>Dataframe and matrix variables:</p> <ul> <li><code>dim()</code>: returns dimensions of the dataset (number_of_rows, number_of_columns) [Note, row numbers will always be displayed before column numbers in R]</li> <li><code>nrow()</code>: returns the number of rows in the dataset</li> <li><code>ncol()</code>: returns the number of columns in the dataset</li> <li><code>rownames()</code>: returns the row names in the dataset  </li> <li><code>colnames()</code>: returns the column names in the dataset</li> </ul> </li> </ul> <p>Exercise 2</p> <ul> <li>Use the <code>class()</code> function on <code>glengths</code> and <code>metadata</code>, how does the output differ between the two?</li> <li>Use the <code>summary()</code> function on the <code>proj_summary</code> dataframe, what is the median \"rRNA_rate\"?</li> <li>How long is the <code>samplegroup</code> factor?</li> <li>What are the dimensions of the <code>proj_summary</code> dataframe?</li> <li>When you use the <code>rownames()</code> function on <code>metadata</code>, what is the data structure of the output?</li> <li>[Optional] How many elements in (how long is) the output of <code>colnames(proj_summary)</code>? Don't count, but use another function to determine this.</li> </ul> <p>Attribution notice</p> <ul> <li> <p>This lesson has been developed by members of the teaching team at the Harvard Chan Bioinformatics Core (HBC). These are open access materials distributed under the terms of the Creative Commons Attribution license (CC BY 4.0), which permits unrestricted use, distribution, and reproduction in any medium, provided the original author and source are credited.</p> </li> <li> <p>The materials used in this lesson are adapted from work that is Copyright \u00a9 Data Carpentry (http://datacarpentry.org/).</p> </li> <li> <p>All Data Carpentry instructional material is made available under the Creative Commons Attribution license (CC BY 4.0).</p> </li> </ul>"},{"location":"day_2/D2.1_in_class_exercises/","title":"Day 2: In class activities","text":""},{"location":"day_2/D2.1_in_class_exercises/#1-custom-functions","title":"1. Custom Functions","text":"<p>Let's create a function <code>temp_conv()</code>, which converts the temperature in Fahrenheit (input) to the temperature in Kelvin (output). </p> <ul> <li> <p>We could perform a two-step calculation: first convert from Fahrenheit to Celsius, and then convert from Celsius to Kelvin.</p> </li> <li> <p>The formula for these two calculations are as follows: temp_c = (temp_f - 32) * 5 / 9; temp_k = temp_c + 273.15.</p> </li> <li> <p>if your input is 70, the result of <code>temp_conv(70)</code> should be 294.2611.</p> </li> </ul>"},{"location":"day_2/D2.1_in_class_exercises/#2-nesting-functions","title":"2. Nesting Functions","text":"<p>Now we want to round the temperature in Kelvin (output of <code>temp_conv()</code>) to a single decimal place. Use the <code>round()</code> function with the newly-created  <code>temp_conv()</code> function to achieve this in one line of code. If your input is 70, the output should now be 294.3.</p> <p>Attribution notice</p> <ul> <li> <p>This lesson has been developed by members of the teaching team at the Harvard Chan Bioinformatics Core (HBC). These are open access materials distributed under the terms of the Creative Commons Attribution license (CC BY 4.0), which permits unrestricted use, distribution, and reproduction in any medium, provided the original author and source are credited.</p> </li> <li> <p>The materials used in this lesson are adapted from work that is Copyright \u00a9 Data Carpentry (http://datacarpentry.org/).</p> </li> <li> <p>All Data Carpentry instructional material is made available under the Creative Commons Attribution license (CC BY 4.0).</p> </li> </ul>"},{"location":"day_2/D2.2_data_wrangling/","title":"Data subsetting with base R: vectors and factors","text":"<p>Approximate time: 60 min</p>"},{"location":"day_2/D2.2_data_wrangling/#learning-objectives","title":"Learning Objectives","text":"<ul> <li>Demonstrate how to subset vectors and factors</li> <li>Explain the use of logical operators when subsetting vectors and factors</li> <li>Demonstrate how to relevel factors in a desired order</li> </ul>"},{"location":"day_2/D2.2_data_wrangling/#selecting-data-using-indices-and-sequences","title":"Selecting data using indices and sequences","text":"<p>When analyzing data, we often want to partition the data so that we are only working with selected columns or rows. A data frame or data matrix is simply a collection of vectors combined together. So let's begin with vectors and how to access different elements, and then extend those concepts to dataframes.</p>"},{"location":"day_2/D2.2_data_wrangling/#vectors","title":"Vectors","text":""},{"location":"day_2/D2.2_data_wrangling/#selecting-using-indices","title":"Selecting using indices","text":"<p>If we want to extract one or several values from a vector, we must provide one or several indices using square brackets <code>[ ]</code> syntax. The index represents the element number within a vector (or the compartment number, if you think of the bucket analogy). R indices start at 1. Programming languages like Fortran, MATLAB, and R start counting at 1, because that's what human beings typically do. Languages in the C family (including C++, Java, Perl, and Python) count from 0 because that's simpler for computers to do.</p> <p>Let's start by creating a vector called age:</p> <p><pre><code>age &lt;- c(15, 22, 45, 52, 73, 81)\n</code></pre> </p> <p>Suppose we only wanted the fifth value of this vector, we would use the following syntax:</p> <pre><code>age[5]\n</code></pre> <p>If we wanted all values except the fifth value of this vector, we would use the following:</p> <pre><code>age[-5]\n</code></pre> <p>If we wanted to select more than one element we would still use the square bracket syntax, but rather than using a single value we would pass in a vector of several index values:</p> <pre><code>age[c(3,5,6)]   ## nested\n\n# OR\n\n## create a vector first then select\nidx &lt;- c(3,5,6) # create vector of the elements of interest\nage[idx]\n</code></pre> <p>To select a sequence of continuous values from a vector, we would use <code>:</code> which is a special function that creates numeric vectors of integer in increasing or decreasing order. Let's select the first four values from age:</p> <pre><code>age[1:4]\n</code></pre> <p>Alternatively, if you wanted the reverse could try <code>4:1</code> for instance, and see what is returned. </p> <p>Exercise</p> <ol> <li>Create a vector called alphabets with the following letters, C, D, X, L, F.</li> <li>Use the associated indices along with <code>[ ]</code> to do the following:<ul> <li>only display C, D and F</li> <li>display all except X</li> <li>display the letters in the opposite order (F, L, X, D, C)</li> </ul> </li> </ol>"},{"location":"day_2/D2.2_data_wrangling/#selecting-using-indices-with-logical-operators","title":"Selecting using indices with logical operators","text":"<p>We can also use indices with logical operators. Logical operators include greater than (&gt;), less than (&lt;), and equal to (==). A full list of logical operators in R is displayed below:</p> Operator Description <code>&gt;</code> greater than <code>&gt;=</code> greater than or equal to <code>&lt;</code> less than <code>&lt;=</code> less than or equal to <code>==</code> equal to <code>!=</code> not equal to <code>&amp;</code> and <code>|</code> or <p>We can use logical expressions to determine whether a particular condition is true or false. For example, let's use our age vector: </p> <pre><code>age\n</code></pre> <p>If we wanted to know if each element in our age vector is greater than 50, we could write the following expression: </p> <pre><code>age &gt; 50\n</code></pre> <p>Returned is a vector of logical values the same length as age with TRUE and FALSE values indicating whether each element in the vector is greater than 50.</p> <pre><code>[1] FALSE FALSE FALSE  TRUE  TRUE  TRUE\n</code></pre> <p>We can use these logical vectors to select only the elements in a vector with TRUE values at the same position or index as in the logical vector.</p> <p>Select all values in the <code>age</code> vector over 50 or <code>age</code> less than 18:</p> <pre><code>age &gt; 50 | age &lt; 18\n\nage\n\nage[age &gt; 50 | age &lt; 18]  ## nested\n\n# OR\n\n## create a vector first then select\nidx &lt;- age &gt; 50 | age &lt; 18\nage[idx]\n</code></pre>"},{"location":"day_2/D2.2_data_wrangling/#indexing-with-logical-operators-using-the-which-function","title":"Indexing with logical operators using the <code>which()</code> function","text":"<p>While logical expressions will return a vector of TRUE and FALSE  values of the same length, we could use the <code>which()</code> function to output the indices where the values are TRUE. Indexing with either method generates the same results, and personal preference determines which method you choose to use. For example:</p> <pre><code>which(age &gt; 50 | age &lt; 18)\n\nage[which(age &gt; 50 | age &lt; 18)]  ## nested\n\n# OR\n\n## create a vector first then select\nidx_num &lt;- which(age &gt; 50 | age &lt; 18)\nage[idx_num]\n</code></pre> <p>Notice that we get the same results regardless of whether or not we use the <code>which()</code>. Also note that while <code>which()</code> works the same as the logical expressions for indexing, it can be used for multiple other operations, where it is not interchangeable with logical expressions.</p>"},{"location":"day_2/D2.2_data_wrangling/#factors","title":"Factors","text":"<p>Since factors are special vectors, the same rules for selecting values using indices apply. The elements of the expression factor created previously had the following categories or levels: low, medium, and high. </p> <p>Let's extract the values of the factor with high expression, and let's using nesting here:</p> <pre><code>expression[expression == \"high\"]    ## This will only return those elements in the factor equal to \"high\"\n</code></pre> <p>Nesting note</p> <p>The piece of code above was more efficient with nesting; we used a single step instead of two steps as shown below:</p> <p>Step1 (no nesting): <code>idx &lt;- expression == \"high\"</code></p> <p>Step2 (no nesting): <code>expression[idx]</code></p> <p>Exercise</p> <p>Extract only those elements in <code>samplegroup</code> that are not KO (nesting the logical operation is optional).</p>"},{"location":"day_2/D2.2_data_wrangling/#releveling-factors","title":"Releveling factors","text":"<p>We have briefly talked about factors, but this data type only becomes more intuitive once you've had a chance to work with it.  Let's take a slight detour and learn about how to relevel categories within a factor. </p> <p>To view the integer assignments under the hood you can use <code>str()</code>:</p> <p><pre><code>expression\n\nstr(expression)\nFactor w/ 3 levels \"high\",\"low\",\"medium\": 2 1 3 1 2 3 1\n</code></pre> The categories are referred to as factor levels. As we learned earlier, the levels in the <code>expression</code> factor were assigned integers alphabetically, with <code>high=1</code>, <code>low=2</code>, <code>medium=3</code>. However, it makes more sense for us if <code>low=1</code>, <code>medium=2</code> and <code>high=3</code>, i.e. it makes sense for us to relevel the categories in this factor.</p> <p>To relevel the categories, you can add the <code>levels</code> argument to the <code>factor()</code> function, and give it a vector with the categories listed in the required order:</p> <pre><code>expression &lt;- factor(expression, levels=c(\"low\", \"medium\", \"high\"))     # you can re-factor a factor \n\nstr(expression)\nFactor w/ 3 levels \"low\",\"medium\",..: 1 3 2 3 1 2 3\n</code></pre> <p>Now we have a releveled factor with low as the lowest or first category, medium as the second and high as the third. This is reflected in the way they are listed in the output of <code>str()</code>, as well as in the numbering of which category is where in the factor.</p> <p>Note</p> <p>Releveling becomes necessary when you need a specific category in a factor to be the \"base\" category, i.e. category that is equal to 1. One example would be if you need the \"control\" to be the \"base\" in a given RNA-seq experiment.</p> <p>Exercise</p> <p>Use the <code>samplegroup</code> factor we created in a previous lesson, and relevel it such that KO is the first level followed by CTL and OE. </p> <p>Attribution notice</p> <ul> <li> <p>This lesson has been developed by members of the teaching team at the Harvard Chan Bioinformatics Core (HBC). These are open access materials distributed under the terms of the Creative Commons Attribution license (CC BY 4.0), which permits unrestricted use, distribution, and reproduction in any medium, provided the original author and source are credited.</p> </li> <li> <p>The materials used in this lesson are adapted from work that is Copyright \u00a9 Data Carpentry (http://datacarpentry.org/).</p> </li> <li> <p>All Data Carpentry instructional material is made available under the Creative Commons Attribution license (CC BY 4.0).</p> </li> </ul>"},{"location":"day_2_exercise/D2.1e_packages_and_libraries/","title":"Packages and libraries","text":"<p>Approximate time: 25 min</p>"},{"location":"day_2_exercise/D2.1e_packages_and_libraries/#learning-objectives","title":"Learning Objectives","text":"<ul> <li>Explain different ways to install external R packages</li> <li>Demonstrate how to load a library and how to find functions specific to a package </li> </ul>"},{"location":"day_2_exercise/D2.1e_packages_and_libraries/#packages-and-libraries","title":"Packages and Libraries","text":"<p>Packages are collections of R functions, data, and compiled code in a well-defined format, created to add specific functionality. There are 10,000+ user contributed packages and growing.</p> <p>There are a set of standard (or base) packages which are considered part of the R source code and automatically available as part of your R installation. Base packages contain the basic functions that allow R to work, and enable standard statistical and graphical functions on datasets; for example, all of the functions that we have been using so far in our examples. </p> <p>The directories in R where the packages are stored are called the libraries. The terms package and library are sometimes used synonymously and there has been discussion amongst the community to resolve this. It is somewhat counter-intuitive to load a package using the <code>library()</code> function and so you can see how confusion can arise.</p> <p>You can check what libraries are loaded in your current R session by typing into the console:</p> <pre><code>sessionInfo() #Print version information about R, the OS and attached or loaded packages\n\n# OR\n\nsearch() #Gives a list of attached packages\n</code></pre> <p>Previously we have introduced you to functions from the standard base packages. However, the more you work with R, you will come to realize that there is a cornucopia of R packages that offer a wide variety of functionality. To use additional packages will require installation. Many packages can be installed from the CRAN or Bioconductor repositories.</p> <p>Helpful tips for package installations</p> <ul> <li>Package names are case sensitive!</li> <li>At any point (especially if you\u2019ve used R/Bioconductor in the past), in the console R may ask you if you want to \"update any old packages by asking Update all/some/none? [a/s/n]:\". If you see this, type \"a\" at the prompt and hit Enter to update any old packages. Updating packages can sometimes take awhile to run. If you are short on time, you can choose \"n\" and proceed. Without updating, you run the risk of conflicts between your old packages and the ones from your updated R version later down the road. </li> <li>If you see a message in your console along the lines of \u201cbinary version available but the source version is later\u201d, followed by a question, \u201cDo you want to install from sources the package which needs compilation? y/n\u201d, type n for no, and hit enter.</li> </ul>"},{"location":"day_2_exercise/D2.1e_packages_and_libraries/#package-installation-from-cran","title":"Package installation from CRAN","text":"<p>CRAN is a repository where the latest downloads of R (and legacy versions) are found in addition to source code for thousands of different user contributed R packages.</p> <p> </p> <p>Packages for R can be installed from the CRAN package repository using the <code>install.packages</code> function. This function will download the source code from on the CRAN mirrors and install the package (and any dependencies) locally on your computer. </p> <p>An example is given below for the <code>ggplot2</code> package that will be required for some plots we will create later on. Run this code to install <code>ggplot2</code>.</p> <pre><code>install.packages(\"ggplot2\")\n</code></pre>"},{"location":"day_2_exercise/D2.1e_packages_and_libraries/#package-installation-from-bioconductor","title":"Package installation from Bioconductor","text":"<p>Alternatively, packages can also be installed from Bioconductor, another repository of packages which provides tools for the analysis and comprehension of high-throughput genomic data. These packages includes (but is not limited to) tools for performing statistical analysis, annotation packages, and accessing public datasets.</p> <p> </p> <p>There are many packages that are available in CRAN and Bioconductor, but there are also packages that are specific to one repository. Generally, you can find out this information with a Google search or by trial and error. </p> <p>To install from Bioconductor, you will first need to install BiocManager. This only needs to be done once ever for your R installation. </p> <p>Do Not Run This!</p> <pre><code>install.packages(\"BiocManager\")\n</code></pre> <p>Now you can use the <code>install()</code> function from the <code>BiocManager</code> package to install a package by providing the name in quotations. </p> <p>Here we have the code to install <code>ggplot2</code>, through Bioconductor:</p> <p>Do Not Run This!</p> <pre><code>BiocManager::install(\"ggplot2\")\n</code></pre> <p>Note</p> <p>The code above may not be familiar to you - it is essentially using a new operator, a double colon <code>::</code> to execute a function from a particular package. This is the syntax: <code>package::function_name()</code>. </p>"},{"location":"day_2_exercise/D2.1e_packages_and_libraries/#package-installation-from-source","title":"Package installation from source","text":"<p>Finally, R packages can also be installed from source. This is useful when you do not have an internet connection (and have the source files locally), since the other two methods are retrieving the source files from remote sites. </p> <p>To install from source, we use the same <code>install.packages</code> function but we have additional arguments that provide specifications to change from defaults:</p> <p>Do Not Run This!</p> <pre><code>install.packages(\"~/Downloads/ggplot2_1.0.1.tar.gz\", type=\"source\", repos=NULL)\n</code></pre>"},{"location":"day_2_exercise/D2.1e_packages_and_libraries/#loading-libraries","title":"Loading libraries","text":"<p>Once you have the package installed, you can load the library into your R session for use. Any of the functions that are specific to that package will be available for you to use by simply calling the function as you would for any of the base functions. Note that quotations are not required here.</p> <pre><code>library(ggplot2)\n</code></pre> <p>You can also check what is loaded in your current environment by using <code>sessionInfo()</code> or <code>search()</code> and you should see your package listed as:</p> <pre><code>other attached packages:\n[1] ggplot2_2.0.0\n</code></pre> <p>In this case there are several other packages that were also loaded along with <code>ggplot2</code>.</p> <p>We only need to install a package once on our computer. However, to use the package, we need to load the library every time we start a new R/RStudio environment. You can think of this as installing a bulb versus turning on the light. </p> <p> </p> <p>Analogy and image credit to Dianne Cook of Monash University. </p>"},{"location":"day_2_exercise/D2.1e_packages_and_libraries/#finding-functions-specific-to-a-package","title":"Finding functions specific to a package","text":"<p>This is your first time using <code>ggplot2</code>, how do you know where to start and what functions are available to you? One way to do this, is by using the <code>Package</code> tab in RStudio. If you click on the tab, you will see listed all packages that you have installed. For those libraries that you have loaded, you will see a blue checkmark in the box next to it. Scroll down to <code>ggplot2</code> in your list:</p> <p> </p> <p>If your library is successfully loaded you will see the box checked, as in the screenshot above. Now, if you click on <code>ggplot2</code> RStudio will open up the help pages and you can scroll through.</p> <p>An alternative is to find the help manual online, which can be less technical and sometimes easier to follow. For example, this website is much more comprehensive for ggplot2 and is the result of a Google search. Many of the Bioconductor packages also have very helpful vignettes that include comprehensive tutorials with mock data that you can work with.</p> <p>If you can't find what you are looking for, you can use the rdocumention.org website that search through the help files across all packages available.</p> <p>Exercise</p> <p>The <code>ggplot2</code> package is part of the <code>tidyverse</code> suite of integrated packages which was designed to work together to make common data science operations more user-friendly. We will be using the <code>tidyverse</code> suite in later lessons, and so let's install it. </p> <p>NOTE:</p> <p>This suite of packages is only available in CRAN._ </p> <p>Attribution notice</p> <ul> <li> <p>This lesson has been developed by members of the teaching team at the Harvard Chan Bioinformatics Core (HBC). These are open access materials distributed under the terms of the Creative Commons Attribution license (CC BY 4.0), which permits unrestricted use, distribution, and reproduction in any medium, provided the original author and source are credited.</p> </li> <li> <p>The materials used in this lesson are adapted from work that is Copyright \u00a9 Data Carpentry (http://datacarpentry.org/).</p> </li> <li> <p>All Data Carpentry instructional material is made available under the Creative Commons Attribution license (CC BY 4.0).</p> </li> </ul>"},{"location":"day_2_exercise/D2.2e_introR-data-wrangling/","title":"Data wrangling: dataframes, matrices, and lists","text":"<p>Approximate time: 60 min</p>"},{"location":"day_2_exercise/D2.2e_introR-data-wrangling/#learning-objectives","title":"Learning Objectives","text":"<ul> <li>Demonstrate how to subset, merge, and create new datasets from existing data structures in R.</li> </ul>"},{"location":"day_2_exercise/D2.2e_introR-data-wrangling/#dataframes","title":"Dataframes","text":"<p>Dataframes (and matrices) have 2 dimensions (rows and columns), so if we want to select some specific data from it we need to specify the \"coordinates\" we want from it. We use the same square bracket notation but rather than providing a single index, there are two indices required. Within the square bracket, row numbers come first followed by column numbers (and the two are separated by a comma). Let's explore the <code>metadata</code> dataframe, shown below are the first six samples:</p> <p> </p> <p>Let's say we wanted to extract the wild type (<code>Wt</code>) value that is present in the first row and the first column. To extract it, just like with vectors, we give the name of the data frame that we want to extract from, followed by the square brackets. Now inside the square brackets we give the coordinates or indices for the rows in which the value(s) are present, followed by a comma, then the coordinates or indices for the columns in which the value(s) are present. We know the wild type value is in the first row if we count from the top, so we put a one, then a comma. The wild type value is also in the first column, counting from left to right, so we put a one in the columns space too. </p> <pre><code># Extract value 'Wt'\nmetadata[1, 1]\n</code></pre> <p>Now let's extract the value <code>1</code> from the first row and third column.</p> <pre><code># Extract value '1'\nmetadata[1, 3] \n</code></pre> <p>Now if you only wanted to select based on rows, you would provide the index for the rows and leave the columns index blank. The key here is to include the comma, to let R know that you are accessing a 2-dimensional data structure:</p> <p><pre><code># Extract third row\nmetadata[3, ] \n</code></pre> What kind of data structure does the output appear to be? We see that it is two-dimensional with row names and column names, so we can surmise that it's likely a data frame.</p> <p>If you were selecting specific columns from the data frame - the rows are left blank:</p> <pre><code># Extract third column\nmetadata[ , 3]   \n</code></pre> <p>What kind of data structure does this output appear to be? It looks different from the data frame, and we really just see a series of values output, indicating a vector data structure. This happens be default if just selecting a single column from a data frame. R will drop to the simplest data structure possible. Since a single column in a data frame is really just a vector, R will output a vector data structure as the simplest data structure. Oftentimes we would like to keep our single column as a data frame. To do this, there is an argument we can add when subsetting called <code>drop</code>, meaning do we want to drop down to the simplest data structure. By default it is <code>TRUE</code>, but we can change it's value to <code>FALSE</code> in order to keep the output as a data frame.</p> <pre><code># Extract third column as a data frame\nmetadata[ , 3, drop = FALSE] \n</code></pre> <p>Just like with vectors, you can select multiple rows and columns at a time. Within the square brackets, you need to provide a vector of the desired values. </p> <p>We can extract consecutive rows or columns using the colon (<code>:</code>) to create the vector of indices to extract.</p> <pre><code># Dataframe containing first two columns\nmetadata[ , 1:2] \n</code></pre> <p>Alternatively, we can use the combine function (<code>c()</code>) to extract any number of rows or columns. Let's extract the first, third, and sixth rows.</p> <pre><code># Data frame containing first, third and sixth rows\nmetadata[c(1,3,6), ] \n</code></pre> <p>For larger datasets, it can be tricky to remember the column number that corresponds to a particular variable. (Is celltype in column 1 or 2? oh, right... they are in column 1). In some cases, the column/row number for values can change if the script you are using adds or removes columns/rows. It's, therefore, often better to use column/row names to refer to extract particular values, and it makes your code easier to read and your intentions clearer.</p> <pre><code># Extract the celltype column for the first three samples\nmetadata[c(\"sample1\", \"sample2\", \"sample3\") , \"celltype\"] \n</code></pre> <p>It's important to type the names of the columns/rows in the exact way that they are typed in the data frame; for instance if I had spelled <code>celltype</code> with a capital <code>C</code>, it would not have worked.</p> <p>If you need to remind yourself of the column/row names, the following functions are helpful:</p> <pre><code># Check column names of metadata data frame\ncolnames(metadata)\n\n# Check row names of metadata data frame\nrownames(metadata)\n</code></pre> <p>If only a single column is to be extracted from a data frame, there is a useful shortcut available. If you type the name of the data frame, then the <code>$</code>, you have the option to choose which column to extract. For instance, let's extract the entire genotype column from our dataset:</p> <pre><code># Extract the genotype column\nmetadata$genotype \n</code></pre> <p>The output will always be a vector, and if desired, you can continue to treat it as a vector. For example, if we wanted the genotype information for the first five samples in <code>metadata</code>, we can use the square brackets (<code>[]</code>) with the indices for the values from the vector to extract:</p> <pre><code># Extract the first five values/elements of the genotype column\nmetadata$genotype[1:5]\n</code></pre> <p>Unfortunately, there is no equivalent <code>$</code> syntax to select a row by name. </p> <p>Exercise</p> <ol> <li>Return a data frame with only the <code>genotype</code> and <code>replicate</code> column values for <code>sample2</code> and <code>sample8</code>.</li> <li>Return the fourth and ninth values of the <code>replicate</code> column.</li> <li>Extract the <code>replicate</code> column as a data frame.</li> </ol>"},{"location":"day_2_exercise/D2.2e_introR-data-wrangling/#selecting-using-indices-with-logical-operators","title":"Selecting using indices with logical operators","text":"<p>With data frames, similar to vectors, we can use logical expressions to extract the rows or columns in the data frame with specific values. First, we need to determine the indices in a rows or columns where a logical expression is <code>TRUE</code>, then we can extract those rows or columns from the data frame. </p> <p>For example, if we want to return only those rows of the data frame with the <code>celltype</code> column having a value of <code>typeA</code>, we would perform two steps:</p> <ol> <li>Identify which rows in the celltype column have a value of <code>typeA</code>.</li> <li>Use those TRUE values to extract those rows from the data frame.</li> </ol> <p>To do this we would extract the column of interest as a vector, with the first value corresponding to the first row, the second value corresponding to the second row, so on and so forth. We use that vector in the logical expression. Here we are looking for values to be equal to <code>typeA</code>, so our logical expression would be:</p> <pre><code>metadata$celltype == \"typeA\"\n</code></pre> <p>This will output TRUE and FALSE values for the values in the vector. The first six values are <code>TRUE</code>, while the last six are <code>FALSE</code>. This means the first six rows of our metadata have a vale of <code>typeA</code> while the last six do not. We can save these values to a variable, which we can call whatever we would like; let's call it <code>logical_idx</code>.</p> <pre><code>logical_idx &lt;- metadata$celltype == \"typeA\"\n</code></pre> <p>Now we can use those <code>TRUE</code> and <code>FALSE</code> values to extract the rows that correspond to the <code>TRUE</code> values from the metadata data frame. We will extract as we normally would a data frame with <code>metadata[ , ]</code>, and we need to make sure we put the <code>logical_idx</code> in the row's space, since those <code>TRUE</code> and <code>FALSE</code> values correspond to the ROWS for which the expression is <code>TRUE</code>/<code>FALSE</code>. We will leave the column's space blank to return all columns.</p> <pre><code>metadata[logical_idx, ]\n</code></pre>"},{"location":"day_2_exercise/D2.2e_introR-data-wrangling/#selecting-indices-with-logical-operators-using-the-which-function","title":"Selecting indices with logical operators using the <code>which()</code> function","text":"<p>As you might have guessed, we can also use the <code>which()</code> function to return the indices for which the logical expression is TRUE. For example, we can find the indices where the <code>celltype</code> is <code>typeA</code> within the <code>metadata</code> dataframe:</p> <pre><code>which(metadata$celltype == \"typeA\")\n</code></pre> <p>This returns the values one through six, indicating that the first 6 values or rows are true, or equal to typeA.  We can save our indices for which rows the logical expression is true to a variable we'll call idx, but, again, you could call it anything you want.</p> <pre><code>idx &lt;- which(metadata$celltype == \"typeA\")\n</code></pre> <p>Then, we can use these indices to indicate the rows that we would like to return by extracting that data as we have previously, giving the <code>idx</code> as the rows that we would like to extract, while returning all columns:</p> <pre><code>metadata[idx, ]\n</code></pre> <p>Let's try another subsetting. Extract the rows of the metadata data frame for only the replicates 2 and 3. First, let's create the logical expression for the column of interest (<code>replicate</code>):</p> <pre><code>which(metadata$replicate &gt; 1)\n</code></pre> <p>This should return the indices for the rows in the <code>replicate</code> column within <code>metadata</code> that have a value of 2 or 3. Now, we can save those indices to a variable and use that variable to extract those corresponding rows from the <code>metadata</code> table.</p> <pre><code>idx &lt;- which(metadata$replicate &gt; 1)\n\nmetadata[idx, ]\n</code></pre> <p>Alternatively, instead of doing this in two steps, we could use nesting to perform in a single step:</p> <pre><code>metadata[which(metadata$replicate &gt; 1), ]\n</code></pre> <p>Either way works, so use the method that is most intuitive for you.</p> <p>So far we haven't stored as variables any of the extractions/subsettings that we have performed. Let's save this output to a variable called <code>sub_meta</code>:</p> <pre><code>sub_meta &lt;- metadata[which(metadata$replicate &gt; 1), ]\n</code></pre> <p>Exercises</p> <p>Subset the <code>metadata</code> dataframe to return only the rows of data with a genotype of <code>KO</code>.</p> <p>NOTE</p> <p>There are easier methods for subsetting dataframes using logical expressions, including the <code>filter()</code> and the <code>subset()</code> functions. These functions will return the rows of the dataframe for which the logical expression is TRUE, allowing us to subset the data in a single step. We will explore the <code>filter()</code> function in more detail in a later lesson.</p>"},{"location":"day_2_exercise/D2.2e_introR-data-wrangling/#lists","title":"Lists","text":"<p>Selecting components from a list requires a slightly different notation, even though in theory a list is a vector (that contains multiple data structures). To select a specific component of a list, you need to use double bracket notation <code>[[]]</code>. Let's use the <code>list1</code> that we created previously, and index the second component:</p> <pre><code>list1[[2]]\n</code></pre> <p>What do you see printed to the console? Using the double bracket notation is useful for accessing the individual components whilst preserving the original data structure. When creating this list we know we had originally stored a dataframe in the second component. With the <code>class</code> function we can check if that is what we retrieve:</p> <pre><code>comp2 &lt;- list1[[2]]\nclass(comp2)\n</code></pre> <p>You can also reference what is inside the component by adding an additional bracket. For example, in the first component we have a vector stored. </p> <pre><code>list1[[1]]\n\n[1] \"ecoli\" \"human\" \"corn\" \n</code></pre> <p>Now, if we wanted to reference the first element of that vector we would use:</p> <pre><code>list1[[1]][1]\n\n[1] \"ecoli\"\n</code></pre> <p>You can also do the same for dataframes and matrices, although with larger datasets it is not advisable. Instead, it is better to save the contents of a list component to a variable (as we did above) and further manipulate it. Also, it is important to note that when selecting components we can only access one at a time. To access multiple components of a list, see the note below. </p> <p>Note</p> <p>Using the single bracket notation also works wth lists. The difference is the class of the information that is retrieved. Using single bracket notation i.e. <code>list1[1]</code> will return the contents in a list form and not the original data structure. The benefit of this notation is that it allows indexing by vectors so you can access multiple components of the list at once.</p> <p>Exercise</p> <ol> <li>Create a list named <code>random</code> with the following components: <code>metadata</code>, <code>age</code>, <code>list1</code>, <code>samplegroup</code>, and <code>number</code>.</li> <li>Extract the <code>samplegroup</code> component.</li> </ol> <p>Assigning names to the components in a list can help identify what each list component contains, as well as, facilitating the extraction of values from list components. </p> <p>Adding names to components of a list uses the <code>names()</code> function. Let's check and see if the <code>list1</code> has names for the components:</p> <pre><code>names(list1) \n</code></pre> <p>When we created the list we had combined the <code>species</code> vector with  a dataframe <code>df</code> and the <code>number</code> variable. Let's assign the original names to the components. To do this we can use the assignment operator in a new context. If we add <code>names(list1)</code> to the left side of the assignment arrow to be assigned to, then anything on the right side of the arrow will be assigned. Since we have three components in <code>list1</code>, we need three names to assign. We can create a vector of names using the combine (<code>c()</code>) function, and inside the combine function we give the names to assign to the components in the order we would like. So the first name is assigned to the first component of the list, and so on.</p> <pre><code># Name components of the list\nnames(list1) &lt;- c(\"species\", \"df\", \"number\")\n\nnames(list1)\n</code></pre> <p>Now that we have named our list components, we can extract components using the <code>$</code> similar to extracting columns from a data frame. To obtain a component of a list using the component name, use <code>list_name$component_name</code>:</p> <p>To extract the <code>df</code> dataframe from the <code>list1</code> list:</p> <pre><code># Extract 'df' component\nlist1$df\n</code></pre> <p>Exercise</p> <p>Let's practice combining ways to extract data from the data structures we have covered so far:</p> <ol> <li> <p>Set names for the <code>random</code> list you created in the last exercise.</p> </li> <li> <p>Extract the <code>age</code> component using the <code>$</code> notation</p> </li> </ol> <p>An R package for data wrangling</p> <p>The methods presented above are using base R functions for data wrangling. Later we will explore the Tidyverse suite of packages, specifically designed to make data wrangling easier.</p> <p>Attribution notice</p> <ul> <li> <p>This lesson has been developed by members of the teaching team at the Harvard Chan Bioinformatics Core (HBC). These are open access materials distributed under the terms of the Creative Commons Attribution license (CC BY 4.0), which permits unrestricted use, distribution, and reproduction in any medium, provided the original author and source are credited.</p> </li> <li> <p>The materials used in this lesson are adapted from work that is Copyright \u00a9 Data Carpentry (http://datacarpentry.org/).</p> </li> <li> <p>All Data Carpentry instructional material is made available under the Creative Commons Attribution license (CC BY 4.0).</p> </li> </ul>"},{"location":"day_2_exercise/D2.3e_identifying-matching-elements/","title":"Advanced R, logical operators for matching","text":"<p>Approximate time: 45 min</p>"},{"location":"day_2_exercise/D2.3e_identifying-matching-elements/#learning-objectives","title":"Learning Objectives","text":"<ul> <li>Describe the use of <code>%in%</code> operator.</li> <li>Explain the user case for <code>any</code> and <code>all</code> functions.</li> </ul>"},{"location":"day_2_exercise/D2.3e_identifying-matching-elements/#logical-operators-for-identifying-matching-elements","title":"Logical operators for identifying matching elements","text":"<p>Oftentimes, we encounter different analysis tools that require multiple input datasets. It is not uncommon for these inputs to need to have the same row names, column names, or unique identifiers in the same order to perform the analysis. Therefore, knowing how to reorder datasets and determine whether the data matches is an important skill.</p> <p>In our use case, we will be working with genomic data. We have gene expression data generated by RNA-seq, which we had downloaded previously; in addition, we have a metadata file corresponding to the RNA-seq samples. The metadata contains information about the samples present in the gene expression file, such as which sample group each sample belongs to and any batch or experimental variables present in the data. </p> <p>Let's read in our gene expression data (RPKM matrix) that we downloaded previously:</p> <pre><code>rpkm_data &lt;- read.csv(\"data/counts.rpkm.csv\")\n</code></pre> <p>Note</p> <p>If the data file name ends with <code>txt</code> instead of <code>csv</code>, you can read in the data using the code: <code>rpkm_data &lt;- read.csv(\"data/counts.rpkm.txt\")</code>. </p> <p>Take a look at the first few lines of the data matrix to see what's in there.</p> <pre><code>head(rpkm_data)\n</code></pre> <p>It looks as if the sample names (header) in our data matrix are similar to the row names of our metadata file, but it's hard to tell since they are not in the same order. We can do a quick check of the number of columns in the count data and the rows in the metadata and at least see if the numbers match up. </p> <pre><code>ncol(rpkm_data)\nnrow(metadata)\n</code></pre> <p>What we want to know is, do we have data for every sample that we have metadata? </p>"},{"location":"day_2_exercise/D2.3e_identifying-matching-elements/#the-in-operator","title":"The <code>%in%</code> operator","text":"<p>Although lacking in documentation, this operator is well-used and convenient once you get the hang of it. The operator is used with the following syntax: </p> <pre><code>vector1 %in% vector2\n</code></pre> <p>It will take each element from vector1 as input, one at a time, and evaluate if the element is present in vector2. The two vectors do not have to be the same size. This operation will return a vector containing logical values to indicate whether or not there is a match. The new vector will be of the same length as vector1. Take a look at the example below:</p> <pre><code>A &lt;- c(1,3,5,7,9,11)   # odd numbers\nB &lt;- c(2,4,6,8,10,12)  # even numbers\n\n# test to see if each of the elements of A is in B  \nA %in% B\n</code></pre> <pre><code>## [1] FALSE FALSE FALSE FALSE FALSE FALSE\n</code></pre> <p>Since vector A contains only odd numbers and vector B contains only even numbers, the operation returns a logical vector containing six <code>FALSE</code>, suggesting that no element in vector A is present in vector B. Let's change a couple of numbers inside vector B to match vector A:</p> <pre><code>A &lt;- c(1,3,5,7,9,11)   # odd numbers\nB &lt;- c(2,4,6,8,1,5)  # add some odd numbers in \n</code></pre> <pre><code># test to see if each of the elements of A is in B\nA %in% B\n</code></pre> <pre><code>## [1]  TRUE FALSE  TRUE FALSE FALSE FALSE\n</code></pre> <p>The returned logical vector denotes which elements in <code>A</code> are also in <code>B</code> - the first and third elements, which are 1 and 5.  </p> <p>We saw previously that we could use the output from a logical expression to subset data by returning only the values corresponding to <code>TRUE</code>. Therefore, we can use the output logical vector to subset our data, and return only those elements in <code>A</code>, which are also in <code>B</code> by returning only the TRUE values:</p> <p> <pre><code>intersection &lt;- A %in% B\nintersection\n</code></pre> </p> <p><pre><code>A[intersection]\n</code></pre> </p> <p>In these previous examples, the vectors were so small that it's easy to check every logical value by eye; but this is not practical when we work with large datasets (e.g. a vector with 1000 logical values). Instead, we can use <code>any</code> function. Given a logical vector, this function will tell you whether at least one value is <code>TRUE</code>. It provides us a quick way to assess if any of the values contained in vector A are also in vector B:</p> <pre><code>any(A %in% B)\n</code></pre> <p>The <code>all</code> function is also useful. Given a logical vector, it will tell you whether all values are <code>TRUE</code>. If there is at least one <code>FALSE</code> value, the <code>all</code> function will return a <code>FALSE</code>. We can use this function to assess whether all elements from vector A are contained in vector B.</p> <pre><code>all(A %in% B)\n</code></pre> <p>Exercise</p> <ol> <li> <p>Using the <code>A</code> and <code>B</code> vectors created above, evaluate each element in <code>B</code> to see if there is a match in <code>A</code></p> </li> <li> <p>Subset the <code>B</code> vector to only return those values that are also in <code>A</code>.</p> </li> </ol> <p>Suppose we had two vectors containing same values. How can we check if those values are in the same order in each vector? In this case, we can use <code>==</code> operator to compare each element of the same position from two vectors. The operator returns a logical vector indicating TRUE/FALSE at each position. Then we can use <code>all()</code> function to check if all values in the returned vector are TRUE. If all values are TRUE, we know that these two vectors are the same. Unlike <code>%in%</code> operator, <code>==</code> operator requires that two vectors are of equal length.  </p> <pre><code>A &lt;- c(10,20,30,40,50)\nB &lt;- c(50,40,30,20,10)  # same numbers but backwards \n\n# test to see if each element of A is in B\nA %in% B\n\n# test to see if each element of A is in the same position in B\nA == B\n\n# use all() to check if they are a perfect match\nall(A == B)\n</code></pre> <p>Let's try this on our genomic data, and see whether we have metadata information for all samples in our expression data. We'll start by creating two vectors: one is the <code>rownames</code> of the metadata, and one is the <code>colnames</code> of the RPKM data. These are base functions in R which allow you to extract the row and column names as a vector:</p> <pre><code>x &lt;- rownames(metadata)\ny &lt;- colnames(rpkm_data)\n</code></pre> <p>Now check to see that all of <code>x</code> are in <code>y</code>:</p> <pre><code>all(x %in% y)\n</code></pre> <p>Note that we can use nested functions in place of <code>x</code> and <code>y</code> and still get the same result:</p> <pre><code>all(rownames(metadata) %in% colnames(rpkm_data))\n</code></pre> <p>We know that all samples are present, but are they in the same order?</p> <pre><code>x == y\nall(x == y)\n</code></pre> <p>Looks like all of the samples are there, but they need to be reordered. To reorder our genomic samples, we will learn different ways to reorder data in our next lesson. But before that, let's work on exercise 2 to consolidate concepts from this lesson.</p> <p>Exercise</p> <p>We have a list of 6 marker genes that we are very interested in. Our goal is to extract count data for these genes using the <code>%in%</code> operator from the <code>rpkm_data</code> data frame, instead of scrolling through <code>rpkm_data</code> and finding them manually.</p> <p>First, let's create a vector called <code>important_genes</code> with the Ensembl IDs of the 6 genes we are interested in:</p> <pre><code>    important_genes &lt;- c(\"ENSMUSG00000083700\", \"ENSMUSG00000080990\", \"ENSMUSG00000065619\", \"ENSMUSG00000047945\", \"ENSMUSG00000081010\", \"ENSMUSG00000030970\")\n</code></pre> <ol> <li> <p>Use the <code>%in%</code> operator to determine if all of these genes are present in the row names of the <code>rpkm_data</code> data frame.</p> </li> <li> <p>Extract the rows from <code>rpkm_data</code> that correspond to these 6 genes using <code>[]</code> and the <code>%in%</code> operator. Double check the row names to ensure that you are extracting the correct rows.</p> </li> <li> <p>Bonus question: Extract the rows from <code>rpkm_data</code> that correspond to these 6 genes using <code>[]</code>, but without using the <code>%in%</code> operator.</p> </li> </ol> <p>Attribution notice</p> <ul> <li> <p>This lesson has been developed by members of the teaching team at the Harvard Chan Bioinformatics Core (HBC). These are open access materials distributed under the terms of the Creative Commons Attribution license (CC BY 4.0), which permits unrestricted use, distribution, and reproduction in any medium, provided the original author and source are credited.</p> </li> <li> <p>The materials used in this lesson are adapted from work that is Copyright \u00a9 Data Carpentry (http://datacarpentry.org/).</p> </li> <li> <p>All Data Carpentry instructional material is made available under the Creative Commons Attribution license (CC BY 4.0).</p> </li> </ul>"},{"location":"day_2_exercise/D2.4e_reordering-to-match-datasets/","title":"Advanced R, reordering to match datasets","text":"<p>Approximate time: 45 min</p>"},{"location":"day_2_exercise/D2.4e_reordering-to-match-datasets/#learning-objectives","title":"Learning Objectives","text":"<ul> <li>Implement manual reordering of vectors and data frames</li> <li>Utilize the <code>match()</code> function to reorder vectors and data frames so that unique identifiers are in the same order</li> </ul>"},{"location":"day_2_exercise/D2.4e_reordering-to-match-datasets/#reordering-data-to-match","title":"Reordering data to match","text":"<p>In the previous lesson, we learned how to determine whether the same data is present in two datasets, in addition to, whether it is in the same order. In this lesson, we will explore how to reorder the data such that the datasets are matching.</p>"},{"location":"day_2_exercise/D2.4e_reordering-to-match-datasets/#manual-reordering-of-data-using-indices","title":"Manual reordering of data using indices","text":"<p>Indexing <code>[ ]</code> can be used to extract values from a dataset as we saw earlier, but we can also use it to rearrange our data values. </p> <p><pre><code>teaching_team &lt;- c(\"Jihe\", \"Mary\", \"Meeta\", \"Radhika\", \"Will\", \"Emma\", \"Heather\", \"Elizabeth\", \"Noor\", \"Upen\")\n</code></pre> </p> <p>Remember that we can return values in a vector by specifying it's position or index:</p> <pre><code># Extracting values from a vector\nteaching_team[c(2, 4)] \n</code></pre> <p>Also, note that we haven't changed the <code>teaching_team</code> variable. The only way to change the <code>teaching_team</code> variable would be to re-assign/overwrite it.</p> <pre><code>teaching_team\n</code></pre> <p>We can also extract the values and reorder them:</p> <pre><code># Extracting values and reordering them\nteaching_team[c(4, 2)] \n</code></pre> <p>Similarly, we can extract all of the values and reorder them:</p> <pre><code># Extracting all values and reordering them\nteaching_team[c(5, 4, 10, 6, 9, 2, 8, 1, 7, 3)]\n</code></pre> <p>If we want to save our results, we need to assign to a variable:</p> <pre><code># Saving the results to a variable\nreorder_teach &lt;- teaching_team[c(5, 4, 10, 6, 9, 2, 8, 1, 7, 3)]\n</code></pre> <p>Exercise</p> <p>Now that we know how to reorder using indices, let's try to use it to reorder the contents of one vector to match the contents of another. Let's create the vectors <code>first</code> and <code>second</code> as detailed below:  </p> <pre><code>first &lt;- c(\"A\",\"B\",\"C\",\"D\",\"E\")\nsecond &lt;- c(\"B\",\"D\",\"E\",\"A\",\"C\")  # same letters but different order\n</code></pre> <p>How would you reorder the <code>second</code> vector to match <code>first</code>?</p> <p>If we had large datasets, it would be difficult to reorder them by searching for the indices of the matching elements, and it would be quite easy to make a typo or mistake. To help with matching datasets, there is a function called <code>match()</code>.</p>"},{"location":"day_2_exercise/D2.4e_reordering-to-match-datasets/#the-match-function","title":"The <code>match</code> function","text":"<p>We can use the <code>match()</code> function to match the values in two vectors. We'll be using it to evaluate which values are present in both vectors, and how to reorder the elements to make the values match.</p> <p>match() takes 2 arguments. The first argument is a vector of values in the order you want, while the second argument is the vector of values to be reordered such that it will match the first:</p> <ol> <li>a vector of values in the order you want</li> <li>a vector of values to be reordered</li> </ol> <p>The function returns the position of the matches (indices) with respect to the second vector, which can be used to re-order it so that it matches the order in the first vector.  Let's use match() on the first and second vectors we created.</p> <pre><code>match(first,second)\n[1] 4 1 5 2 3\n</code></pre> <p>The output is the indices for how to reorder the second vector to match the first. These indices match the indices that we derived manually before.</p> <p>Now, we can just use the indices to reorder the elements of the <code>second</code> vector to be in the same positions as the matching elements in the <code>first</code> vector:</p> <pre><code># Saving indices for how to reorder `second` to match `first`\nreorder_idx &lt;- match(first,second) \n</code></pre> <p>Then, we can use those indices to reorder the second vector similar to how we ordered with the manually derived indices.</p> <pre><code># Reordering the second vector to match the order of the first vector\nsecond[reorder_idx]\n</code></pre> <p>If the output looks good, we can save the reordered vector to a new variable.</p> <pre><code># Reordering and saving the output to a variable\nsecond_reordered &lt;- second[reorder_idx]  \n</code></pre> <p> </p> <p>Now that we know how <code>match()</code> works, let's change vector <code>second</code> so that only a subset are retained:</p> <p><pre><code>first &lt;- c(\"A\",\"B\",\"C\",\"D\",\"E\")\nsecond &lt;- c(\"D\",\"B\",\"A\")  # remove values\n</code></pre>  And try to <code>match()</code> again:</p> <pre><code>match(first,second)\n\n[1]  3  2 NA  1 NA\n</code></pre> <p>We see that the <code>match()</code> function takes every element in the first vector and finds the position of that element in the second vector, and if that element is not present, will return a missing value of NA. The value NA represents missing data for any data type within R. In this case, we can see that the <code>match()</code> function output represents the value at position 3 as first, which is A, then position 2 is next, which is B, the value coming next is supposed to be C, but it is not present in the <code>second</code> vector, so NA is returned, so on and so forth.</p> <p>Note</p> <p>For values that don't match by default return an <code>NA</code> value. You can specify what values you would have it assigned using <code>nomatch</code> argument. Also, if there is more than one matching value found only the first is reported.</p> <p>If we rearrange <code>second</code> using these indices, then we should see that all the values present in both vectors are in the same positions and NAs are present for any missing values.</p> <pre><code>second[match(first, second)]\n</code></pre>"},{"location":"day_2_exercise/D2.4e_reordering-to-match-datasets/#reordering-genomic-data-using-match-function","title":"Reordering genomic data using <code>match()</code> function","text":"<p>While the input to the <code>match()</code> function is always going to be to vectors, often we need to use these vectors to reorder the rows or columns of a data frame to match the rows or columns of another dataframe. Let's explore how to do this with our use case featuring RNA-seq data. To perform differential gene expression analysis, we have a data frame with the expression data or counts for every sample and another data frame with the information about to which condition each sample belongs. For the tools doing the analysis, the samples in the counts data, which are the column names, need to be the same and in the same order as the samples in the metadata data frame, which are the rownames.</p> <p>We can take a look at these samples in each dataset by using the <code>rownames()</code> and <code>colnames()</code> functions.</p> <pre><code># Check row names of the metadata\nrownames(metadata)\n\n# Check the column names of the counts data\ncolnames(rpkm_data)\n</code></pre> <p>We see the row names of the metadata are in a nice order starting at <code>sample1</code> and ending at <code>sample12</code>, while the column names of the counts data look to be the same samples, but are randomly ordered. Therefore, we want to reorder the columns of the counts data to match the order of the row names of the metadata. To do so, we will use the <code>match()</code> function to match the row names of our metadata with the column names of our counts data, so these will be the arguments for match. </p> <p>To do so, we will use the match function to match the row names of our metadata with the column names of our counts data, so these will be the arguments for <code>match()</code>. </p> <p>Within the <code>match()</code> function, the rownames of the metadata is the vector in the order that we want, so this will be the first argument, while the column names of the count or rpkm data is the vector to be reordered. We will save these indices for how to reorder the column names of the count data such that it matches the rownames of the metadata to a variable called <code>genomic idx</code>.</p> <pre><code>genomic_idx &lt;- match(rownames(metadata), colnames(rpkm_data))\ngenomic_idx\n</code></pre> <p>The <code>genomic_idx</code> represents how to re-order the column names in our counts data to be identical to the row names in metadata. </p> <p>Now we can create a new counts data frame in which the columns are re-ordered based on the <code>match()</code> indices. Remember that to reorder the rows or columns in a data frame we give the name of the data frame followed by square brackets, and then the indices for how to reorder the rows or columns.</p> <p>Our <code>genomic_idx</code> represents how we would need to reorder the columns of our count data such that the column names would be in the same order as the row names of our metadata. Therefore, we need to add our <code>genomic_idx</code> to the columns position. We are going to save the output of the reordering to a new data frame called <code>rpkm_ordered</code>.</p> <pre><code># Reorder the counts data frame to have the sample names in the same order as the metadata data frame\nrpkm_ordered  &lt;- rpkm_data[ , genomic_idx]\n</code></pre> <p>Check and see what happened by clicking on the <code>rpkm_ordered</code> in the Environment window or using the <code>View()</code> function. </p> <pre><code># View the reordered counts\nView(rpkm_ordered)\n</code></pre> <p>We can see the sample names are now in a nice order from sample 1 to 12, just like the metadata. One thing to note is that you would never want to rearrange just the column names without the rest of the column because that would dissociate the sample name from it's values.</p> <p>You can also verify that column names of this new data matrix matches the metadata row names by using the <code>all</code> function:</p> <pre><code>all(rownames(metadata) == colnames(rpkm_ordered))\n</code></pre> <p>Now that our samples are ordered the same in our metadata and counts data, if these were raw counts (not RPKM) we could proceed to perform differential expression analysis with this dataset.</p> <p>Exercise</p> <ol> <li> <p>After talking with your collaborator, it becomes clear that <code>sample2</code> and <code>sample9</code> were actually from a different mouse background than the other samples and should not be part of our analysis. Create a new variable called <code>subset_rpkm</code> that has these columns removed from the <code>rpkm_ordered</code> data frame.</p> </li> <li> <p>Use the <code>match()</code> function to subset the <code>metadata</code> data frame so that the row names of the <code>metadata</code> data frame match the column names of the <code>subset_rpkm</code> data frame.</p> </li> </ol> <p>Attribution notice</p> <ul> <li> <p>This lesson has been developed by members of the teaching team at the Harvard Chan Bioinformatics Core (HBC). These are open access materials distributed under the terms of the Creative Commons Attribution license (CC BY 4.0), which permits unrestricted use, distribution, and reproduction in any medium, provided the original author and source are credited.</p> </li> <li> <p>The materials used in this lesson are adapted from work that is Copyright \u00a9 Data Carpentry (http://datacarpentry.org/).</p> </li> <li> <p>All Data Carpentry instructional material is made available under the Creative Commons Attribution license (CC BY 4.0).</p> </li> </ul>"},{"location":"day_2_exercise/D2.5e_setting_up_to_plot/","title":"Plotting and data visualization in R","text":""},{"location":"day_2_exercise/D2.5e_setting_up_to_plot/#learning-objectives","title":"Learning Objectives","text":"<ul> <li>Describe the <code>map()</code> function for iterative tasks on data structures.</li> </ul>"},{"location":"day_2_exercise/D2.5e_setting_up_to_plot/#setting-up-a-data-frame-for-visualization","title":"Setting up a data frame for visualization","text":"<p>In this lesson we want to make plots to evaluate the average expression in each sample and its relationship with the age of the mouse. So, to this end, we will be adding a couple of additional columns of information to the <code>metadata</code> data frame that we can utilize for plotting. </p> <p> </p>"},{"location":"day_2_exercise/D2.5e_setting_up_to_plot/#calculating-average-expression","title":"Calculating average expression","text":"<p>Let's take a closer look at our counts data. Each column represents a sample in our experiment, and each sample has ~38K values corresponding to the expression of different transcripts. We want to compute the average value of expression for each sample eventually. Taking this one step at a time, what would we do if we just wanted the average expression for Sample 1 (across all transcripts)? We can use the R base package provided function called <code>mean()</code>:</p> <pre><code>mean(rpkm_ordered$sample1)\n</code></pre> <p>That is great, if we only wanted the average from one of the samples (1 column in a data frame), but we need to get this information from all 12 samples, so all 12 columns. It would be ideal to get a vector of 12 values that we can add to the metadata data frame. What is the best way to do this?</p> <p>Programming languages typically have a way to allow the execution of a single line of code or several lines of code multiple times, or in a \"loop\". While \"for loops\" are available in R, there are other easier-to-use functions that can achieve this -  for example, the <code>apply()</code> family of functions and the <code>map()</code> family of functions. </p> <p>The <code>map()</code> family is a bit more intuitive to use than <code>apply()</code> and we will be using it today. However, if you are interested in learning more about the<code>apply()</code> family of functions we have materials available here.</p> <p>To obtain mean values for all samples we can use the <code>map_dbl()</code> function which generates a numeric vector. </p> <pre><code>library(purrr)  # Load the purrr\n\nsamplemeans &lt;- map_dbl(rpkm_ordered, mean) \n</code></pre>"},{"location":"day_2_exercise/D2.5e_setting_up_to_plot/#the-map-family-of-functions","title":"The <code>map</code> family of functions","text":"<p>The <code>map()</code> family of functions is available from the <code>purrr</code> package, which is part of the tidyverse suite of packages. More detailed information is available in the R for Data Science book. This family includes several functions, each taking a vector as input and outputting a vector of a specified type. For example, we can use these functions to execute some task/function on every element in a vector, or every column in a dataframe, or every component of a list, and so on. </p> <ul> <li><code>map()</code> creates a list.</li> <li><code>map_lgl()</code> creates a logical vector.</li> <li><code>map_int()</code> creates an integer vector.</li> <li><code>map_dbl()</code> creates a \"double\" or numeric vector.</li> <li><code>map_chr()</code> creates a character vector.</li> </ul> <p>The syntax for the <code>map()</code> family of functions is: </p> <pre><code>## DO NOT RUN\nmap(object, function_to_apply)\n</code></pre> <p>If you would like to practice with the <code>map()</code> family of functions, we have additional materials available.</p>"},{"location":"day_2_exercise/D2.5e_setting_up_to_plot/#creating-a-new-metadata-object-with-additional-information","title":"Creating a new metadata object with additional information","text":"<p>Because the input was 12 columns of information the output of <code>map_dbl()</code> is a named vector of length 12. </p> <pre><code># Named vectors have a name assigned to each element instead of just referring to them as indices ([1], [2] and so on)\nsamplemeans\n\n# Check length of the vector before adding it to the data frame\nlength(samplemeans)\n</code></pre> <p>Since we have 12 rows in the data frame, we can add the 12 element vector as a column to our metadata data frame using the <code>data.frame()</code> function.</p> <p>Before we add the new column, let's create a vector with the ages of each of the mice in our data set.</p> <pre><code># Create a numeric vector with ages. Note that there are 12 elements here\nage_in_days &lt;- c(40, 32, 38, 35, 41, 32, 34, 26, 28, 28, 30, 32)        \n</code></pre> <p>Now, we are ready to combine the <code>metadata</code> data frame with the 2 new vectors to create a new data frame with 5 columns</p> <pre><code># Add the new vector as the last column to the new_metadata dataframe\nnew_metadata &lt;- data.frame(metadata, samplemeans, age_in_days) \n\n# Take a look at the new_metadata object\nView(new_metadata)\n</code></pre> <p>Note</p> <p>that we could have also combined columns using the <code>cbind()</code> function as shown in the code below: <pre><code>## DO NOT RUN\nnew_metadata &lt;- cbind(metadata, samplemeans, age_in_days)\n</code></pre> The two functions work identically with the exception of assigning row names. For example, if we were combining columns and wanted to add in a vector of row names, we could easily do so in <code>data.frame()</code> with the use of the <code>row.names</code> argument. This argument is not available for the <code>cbind()</code> function.</p> <p>We are now ready for plotting and data visualization!</p> <p>Attribution notice</p> <ul> <li> <p>This lesson has been developed by members of the teaching team at the Harvard Chan Bioinformatics Core (HBC). These are open access materials distributed under the terms of the Creative Commons Attribution license (CC BY 4.0), which permits unrestricted use, distribution, and reproduction in any medium, provided the original author and source are credited.</p> </li> <li> <p>The materials used in this lesson are adapted from work that is Copyright \u00a9 Data Carpentry (http://datacarpentry.org/).</p> </li> <li> <p>All Data Carpentry instructional material is made available under the Creative Commons Attribution license (CC BY 4.0).</p> </li> </ul>"},{"location":"day_3/D3.1_in_class_exercises/","title":"Day 3: In class activities","text":""},{"location":"day_3/D3.1_in_class_exercises/#reading-in-and-inspecting-data","title":"Reading in and inspecting data","text":"<ul> <li>Download the data and place the file into the <code>data</code> directory.</li> </ul> Data Download link Animal data Right click &amp; Save link as... <ul> <li> <p>Read the <code>.csv</code> file into your environment and assign it to a variable called <code>animals</code>. Be sure to check that your row names are the different animals.</p> </li> <li> <p>Check to make sure that <code>animals</code> is a dataframe.</p> </li> <li> <p>How many rows are in the <code>animals</code> dataframe? How many columns?</p> </li> </ul>"},{"location":"day_3/D3.1_in_class_exercises/#data-wrangling","title":"Data wrangling","text":"<ol> <li> <p>Extract the <code>speed</code> value of 40 km/h from the <code>animals</code> dataframe.</p> </li> <li> <p>Return the rows with animals that are the <code>color</code> Tan.</p> </li> <li> <p>Return the rows with animals that have <code>speed</code> greater than 50 km/h and output only the <code>color</code> column. Keep the output as a data frame.  </p> </li> <li> <p>Change the color of \"Grey\" to \"Gray\". </p> </li> <li> <p>Create a list called <code>animals_list</code> in which the first element contains the speed column of the <code>animals</code> dataframe and the second element contains the color column of the <code>animals</code> dataframe. </p> </li> <li> <p>Give each element of your list the appropriate name (i.e speed and color).</p> </li> </ol>"},{"location":"day_3/D3.1_in_class_exercises/#the-in-operator-reordering-and-matching","title":"The <code>%in%</code> operator, reordering and matching","text":"<p>In your environment you should have a dataframe called <code>proj_summary</code> which contains quality metric information for an RNA-seq dataset. We have obtained batch information for the control samples in this dataset. </p> <ol> <li>Copy and paste the code below to create a dataframe of control samples with the associated batch information</li> </ol> <pre><code>    ctrl_samples &lt;- data.frame(row.names = c(\"sample3\", \"sample10\", \"sample8\", \"sample4\", \"sample15\"), date = c(\"01/13/2018\", \"03/15/2018\", \"01/13/2018\", \"09/20/2018\",\"03/15/2018\"))\n</code></pre> <ol> <li> <p>How many of the <code>ctrl_samples</code> are also in the <code>proj_summary</code> dataframe? Use the <code>%in%</code> operator to compare sample names. </p> </li> <li> <p>Keep only the rows in <code>proj_summary</code> which correspond to those in <code>ctrl_samples</code>. Do this with the %in% operator. Save it to a variable called <code>proj_summary_ctrl</code>.</p> </li> <li> <p>We would like to add in the batch information for the samples in <code>proj_summary_ctrl</code>. Find the rows that match in <code>ctrl_samples</code>.</p> </li> <li> <p>Use <code>cbind()</code> to add a column called <code>batch</code> to the <code>proj_summary_ctrl</code> dataframe. Assign this new dataframe back to <code>proj_summary_ctrl</code>.</p> </li> </ol>"},{"location":"day_3/D3.1_in_class_exercises/#bonus-using-map_lgl","title":"BONUS: Using <code>map_lgl()</code>","text":"<ol> <li> <p>Subset <code>proj_summary</code> to keep only the \u201chigh\u201d and \u201clow\u201d samples based on the treament column. Save the new dataframe to a variable called <code>proj_summary_noctl</code>.</p> </li> <li> <p>Further, subset the dataframe to remove the non-numeric columns \u201cQuality_format\u201d, and \u201ctreatment\u201d. Try to do this using the <code>map_lgl()</code> function in addition to <code>is.numeric()</code>. Save the new dataframe back to <code>proj_summary_noctl</code>.</p> </li> </ol> <p>Attribution notice</p> <ul> <li> <p>This lesson has been developed by members of the teaching team at the Harvard Chan Bioinformatics Core (HBC). These are open access materials distributed under the terms of the Creative Commons Attribution license (CC BY 4.0), which permits unrestricted use, distribution, and reproduction in any medium, provided the original author and source are credited.</p> </li> <li> <p>The materials used in this lesson are adapted from work that is Copyright \u00a9 Data Carpentry (http://datacarpentry.org/).</p> </li> <li> <p>All Data Carpentry instructional material is made available under the Creative Commons Attribution license (CC BY 4.0).</p> </li> </ul>"},{"location":"day_3/D3.2_plotting_with_ggplot2/","title":"Plotting and data visualization in R","text":"<p>Approximate time: 60 minutes</p>"},{"location":"day_3/D3.2_plotting_with_ggplot2/#learning-objectives","title":"Learning Objectives","text":"<ul> <li>Explain the syntax of ggplot2</li> <li>Apply ggplot2 package to visualize data.</li> </ul>"},{"location":"day_3/D3.2_plotting_with_ggplot2/#data-visualization-with-ggplot2","title":"Data Visualization with <code>ggplot2</code>","text":"<p>For this lesson, you will need the <code>new_metadata</code> data frame. Please download it from the link below. Right click and save link as or download file as in the data directory.</p> Data Download link Data Right click &amp; Save link as... <p>Once you have downloaded it, load it into your environment as follows:</p> <pre><code>## load the new_metadata data frame into your environment from a .RData object\nload(\"data/new_metadata.RData\")\n</code></pre> <p>Next, let's check if it was successfully loaded into the environment:</p> <pre><code># this data frame should have 12 rows and 5 columns\nView(new_metadata)\n</code></pre> <p>Great, we are now ready to move forward!</p> <p>When we are working with large sets of numbers it can be useful to display that information graphically to gain more insight. In this lesson we will be plotting with the popular Bioconductor package <code>ggplot2</code>.</p> <p>Note</p> <p>If you are interested in learning about plotting with base R functions, we have a short lesson. </p> <p>The <code>ggplot2</code> syntax takes some getting used to, but once you get it, you will find it's extremely powerful and flexible. We will start with drawing a simple x-y scatterplot of <code>samplemeans</code> versus <code>age_in_days</code> from the <code>new_metadata</code> data frame. Please note that <code>ggplot2</code> expects a \"data frame\" or \"tibble\" as input.</p> <p>Note</p> <p>You can find out more about tibbles in the lesson on tidyverse</p> <p>Let's start by loading the <code>ggplot2</code> library:</p> <pre><code>library(ggplot2)\n</code></pre> <p>The <code>ggplot()</code> function is used to initialize the basic graph structure, then we add to it. The basic idea is that you specify different parts of the plot using additional functions one after the other and combine them into a \"code chunk\" using the <code>+</code> operator; the functions in the resulting code chunk are called layers.</p> <p>Try the code below and see what happens. </p> <pre><code>ggplot(new_metadata) # what happens? \n</code></pre> <p>Metadata</p> <p>If you don't have the new_metadata object, you can right-click to download and save an <code>rds</code> file from here into the project <code>data</code> folder, and load it in using the code below: <pre><code>new_metadata &lt;- readRDS(\"data/new_metadata.rds\")`\n</code></pre></p> <p>You get an blank plot, because you need to specify additional layers using the <code>+</code> operator.</p> <p>The geom (geometric) object is the layer that specifies what kind of plot we want to draw. A plot must have at least one <code>geom</code>; there is no upper limit. Examples include:</p> <ul> <li>points (<code>geom_point</code>, <code>geom_jitter</code> for scatter plots, dot plots, etc)</li> <li>lines (<code>geom_line</code>, for time series, trend lines, etc)</li> <li>boxplot (<code>geom_boxplot</code>, for, well, boxplots!)</li> </ul> <p>Let's add a \"geom\" layer to our plot using the <code>+</code> operator, and since we want a scatter plot so we will use <code>geom_point()</code>.</p> <pre><code>ggplot(new_metadata) +\n  geom_point() # note what happens here\n</code></pre> <p>Why do we get an error? Is the error message easy to decipher?</p> <p>We get an error because each type of <code>geom</code> usually has a required set of aesthetics to be set. \"Aesthetics\" are set with the <code>aes()</code> function and can be set either nested within <code>geom_point()</code> (applies only to that layer) or within <code>ggplot()</code> (applies to the whole plot).</p> <p>The <code>aes()</code> function has many different arguments, and all of those arguments take columns from the original data frame as input. It can be used to specify many plot elements including the following:</p> <ul> <li>position (i.e., on the x and y axes)</li> <li>color (\"outside\" color)</li> <li>fill (\"inside\" color) </li> <li>shape (of points)</li> <li>linetype</li> <li>size</li> </ul> <p>To start, we will specify x- and y-axis since <code>geom_point</code> requires the most basic information about a scatterplot, i.e. what you want to plot on the x and y axes. All of the other plot elements mentioned above are optional.</p> <pre><code>ggplot(new_metadata) +\n     geom_point(aes(x = age_in_days, y= samplemeans))\n</code></pre> <p> </p> <p>Now that we have the required aesthetics, let's add some extras like color to the plot. We can <code>color</code> the points on the plot based on the genotype column within <code>aes()</code>. You will notice that there are a default set of colors that will be used so we do not have to specify. Note that the legend has been conveniently plotted for us.</p> <pre><code>ggplot(new_metadata) +\n  geom_point(aes(x = age_in_days, y= samplemeans, color = genotype)) \n</code></pre> <p> </p> <p>Let's try to have both celltype and genotype represented on the plot. To do this we can assign the <code>shape</code> argument in <code>aes()</code> the celltype column, so that each celltype is plotted with a different shaped data point. </p> <pre><code>ggplot(new_metadata) +\n  geom_point(aes(x = age_in_days, y= samplemeans, color = genotype,\n            shape=celltype)) \n</code></pre> <p> </p> <p>The data points are quite small. We can adjust the size of the data points within the <code>geom_point()</code> layer, but it should not be within <code>aes()</code> since we are not mapping it to a column in the input data frame, instead we are just specifying a number. </p> <pre><code>ggplot(new_metadata) +\n  geom_point(aes(x = age_in_days, y= samplemeans, color = genotype,\n            shape=celltype), size=2.25) \n</code></pre> <p> </p> <p>The labels on the x- and y-axis are also quite small and hard to read. To change their size, we need to add an additional theme layer. The ggplot2 <code>theme</code> system handles non-data plot elements such as:</p> <ul> <li>Axis label aesthetics</li> <li>Plot background</li> <li>Facet label backround</li> <li>Legend appearance</li> </ul> <p>There are built-in themes we can use (i.e. <code>theme_bw()</code>) that mostly change the background/foreground colours, by adding it as additional layer. Or we can adjust specific elements of the current default theme by adding the <code>theme()</code> layer and passing in arguments for the things we wish to change. Or we can use both.</p> <p>Let's add a layer <code>theme_bw()</code>. </p> <pre><code>ggplot(new_metadata) +\n  geom_point(aes(x = age_in_days, y= samplemeans, color = genotype,\n            shape=celltype), size=3.0) +\n  theme_bw() \n</code></pre> <p>Do the axis labels or the tick labels get any larger by changing themes?</p> <p>No, they don't. But, we can add arguments using <code>theme()</code> to change the size of axis labels ourselves. Since we will be adding this layer \"on top\", or after <code>theme_bw()</code>, any features we change will override what is set by the <code>theme_bw()</code> layer. </p> <p>Let's increase the size of both the axes titles to be 1.5 times the default size. When modifying the size of text the <code>rel()</code> function is commonly used to specify a change relative to the default.</p> <pre><code>ggplot(new_metadata) +\n  geom_point(aes(x = age_in_days, y= samplemeans, color = genotype,\n            shape=celltype), size=2.25) +\n  theme_bw() +\n  theme(axis.title = element_text(size=rel(1.5)))           \n</code></pre> <p> </p> <p>Notes</p> <ul> <li>You can use the <code>example(\"geom_point\")</code> function here to explore a multitude of different aesthetics and layers that can be added to your plot. As you scroll through the different plots, take note of how the code is modified. You can use this with any of the different geometric object layers available in ggplot2 to learn how you can easily modify your plots! </li> <li>RStudio provide this very useful cheatsheet for plotting using <code>ggplot2</code>. Different example plots are provided and the associated code (i.e which <code>geom</code> or <code>theme</code> to use in the appropriate situation.) We also encourage you to peruse through this useful online reference for working with ggplot2.</li> </ul> <p>Exercise</p> <ol> <li>The current axis label text defaults to what we gave as input to <code>geom_point</code> (i.e the column headers). We can change this by adding additional layers called <code>xlab()</code> and <code>ylab()</code> for the x- and y-axis, respectively. Add these layers to the current plot such that the x-axis is labeled \"Age (days)\" and the y-axis is labeled \"Mean expression\".</li> <li>Use the <code>ggtitle</code> layer to add a plot title of your choice. </li> <li>Add the following new layer to the code chunk <code>theme(plot.title=element_text(hjust=0.5))</code>.<ul> <li>What does it change?</li> <li>How many theme() layers can be added to a ggplot code chunk, in your estimation?</li> </ul> </li> </ol> <p>Attribution notice</p> <ul> <li> <p>This lesson has been developed by members of the teaching team at the Harvard Chan Bioinformatics Core (HBC). These are open access materials distributed under the terms of the Creative Commons Attribution license (CC BY 4.0), which permits unrestricted use, distribution, and reproduction in any medium, provided the original author and source are credited.</p> </li> <li> <p>The materials used in this lesson are adapted from work that is Copyright \u00a9 Data Carpentry (http://datacarpentry.org/).</p> </li> <li> <p>All Data Carpentry instructional material is made available under the Creative Commons Attribution license (CC BY 4.0).</p> </li> </ul>"},{"location":"day_3/basic_plots_in_r/","title":"Plotting and data visualization in R (basics)","text":"<p>Approximate time: 45 minutes</p>"},{"location":"day_3/basic_plots_in_r/#basic-plots-in-r","title":"Basic plots in R","text":"<p>R has a number of built-in tools for basic graph types such as histograms, scatter plots, bar charts, boxplots and much more. Rather than going through all of different types, we will focus on <code>plot()</code>, a generic function for plotting x-y data. </p> <p>To get a quick view of the different things you can do with <code>plot</code>, let's use the <code>example()</code> function: <pre><code>example(\"plot\")\n</code></pre></p> <p>Here, you will find yourself having to press <code>&lt;Return&gt;</code> so you can scroll through the different types of graphs generated by <code>plot</code>. Take note of the different parameters used with each command and how that affects the aesthetics of the plot. </p> <pre><code>dev.off() \n# this means \"device off\" and we will be going over what this does at the end of this section. \n# For now, it makes it so that when we draw plots they show up where they are supposed to?\n</code></pre>"},{"location":"day_3/basic_plots_in_r/#scatterplot","title":"Scatterplot","text":"<p>For some hands-on practice we are going to use <code>plot</code> to draw a scatter plot and obtain a graphical view of the relationship between two sets of continuous numeric data. From our new_metadata file we will take the <code>samplemeans</code> column and plot it against <code>age_in_days</code>, to see how mean expression changes with age. </p> <p>Now our metadata has all the information to draw a scatterplot. The base R function to do this is <code>plot(y ~ x, data)</code>: <pre><code>plot(samplemeans ~ age_in_days, data=new_metadata)\n</code></pre></p> <p> </p> <p>Each point represents a sample. The values on the y-axis correspond to the average expression for each sample which is dependent on the x-axis variable <code>age_in_days</code>. This plot is in its simplest form, we can customize many features of the plot (fonts, colors, axes, titles) through graphic options.</p> <p>For example, let's start by giving our plot a title and renaming the axes. We can do that by simply adding the options <code>xlab</code>, <code>ylab</code> and <code>main</code> as arguments to the <code>plot()</code> function:</p> <pre><code>plot(samplemeans ~ age_in_days, data=new_metadata, main=\"Expression changes with age\", xlab=\"Age (days)\", \n    ylab=\"Mean expression\")\n</code></pre> <p> </p> <p>We can also change the shape of the data point using the <code>pch</code> option and the size of the data points using <code>cex</code> (specifying the amount to magnify relative to the default).</p> <pre><code>plot(samplemeans ~ age_in_days, data=new_metadata, main=\"Expression changes with age\", xlab=\"Age (days)\", \n    ylab=\"Mean expression\", pch=\"*\", cex=2.0)\n</code></pre> <p></p> <p>We can also add some color to the data points on the plot by adding <code>col=\"blue\"</code>. Alternatively, you can sub in any of the default colors or you can experiment with other R packages to fiddle with better palettes. </p> <p>We can also add color to separate the data points by information in our data frame. For example, suppose we wanted to the data points colored by celltype. We would need to specify a vector of colours and provide the factor by which we are separating samples. The first level in our factor vector (which by default is assigned alphabetically) would get assigned the first color that we list. So in this case, blue corresponds to celltype A samples and green corresponds to celltype B.</p> <pre><code>plot(samplemeans ~ age_in_days, data=new_metadata, main=\"Expression changes with age\", xlab=\"Age (days)\", \n    ylab=\"Mean expression\", pch=\"*\", cex=2.0, col=c(\"blue\", \"green\")[celltype])\n</code></pre> <p></p> <p>The last thing this plot needs is a figure legend describing the color scheme. It would be great if it created one for you by default, but with R base functions unfortunately it is not that easy. To draw a legend on the current plot, you need to run a new function called <code>legend()</code> and specify the appropriate arguments. The code to do so is provided below. Don't worry if it seems confusing, we plan on showing you a much more intuitive way of plotting your data.</p> <p><pre><code>legend(\"topleft\", pch=\"*\", col=c(\"blue\", \"green\"), c(\"A\", \"B\"), cex=0.8,\n    title=\"Celltype\")\n</code></pre> </p> <p>Exercise </p> <ol> <li> <p>Change the color scheme in the scatterplot, such that it reflects the <code>genotype</code> of samples rather than <code>celltype</code>.</p> </li> <li> <p>Use R help to find out how to increase the size of the text on the axis labels.</p> </li> </ol> <p>This lesson has been developed by members of the teaching team at the Harvard Chan Bioinformatics Core (HBC). These are open access materials distributed under the terms of the Creative Commons Attribution license (CC BY 4.0), which permits unrestricted use, distribution, and reproduction in any medium, provided the original author and source are credited.</p>"},{"location":"day_3/basic_plots_in_r/#other-types-of-plots-in-base-r","title":"Other Types of Plots in Base R","text":"<p>NOTE: we will not run these in class, but the code is provided if you are interested in exploring more on your own.</p>"},{"location":"day_3/basic_plots_in_r/#barplot","title":"Barplot","text":"<p>Barplots are useful for comparing the distribution of a quantitative variable (numeric) between groups or categories. A barplot  would be much more useful to compare the samplemeans (numeric variable) for each sample. We can use <code>barplot</code> to draw a single bar representing each sample and the height indicates the average expression level. </p> <p><pre><code>?barplot\n# note that there is no \"data=\" argument for barplot()\n</code></pre> Similar to the scatterplot, we can use additional arguments to specify the aesthetics that we want to change. For example, changing axis labeling and adding some color. <pre><code>barplot(new_metadata$samplemeans, names.arg=c(1:12), horiz=TRUE, col=c(\"darkblue\", \"red\")[new_metadata$genotype]) \n</code></pre> </p>"},{"location":"day_3/basic_plots_in_r/#histogram","title":"Histogram","text":"<p>If we are interested in an overall distribution of numerical data, a histogram is what we'd want. To plot a histogram of the data use the <code>hist</code> command: <pre><code>hist(new_metadata$samplemeans)\n</code></pre> Again, there are many options that we can change by modifying the default parameters. Let's color in the bars, remove the borders and increase the number of breaks: <pre><code>hist(new_metadata$samplemeans, xlab=\"Mean expression level\", main=\"\", col=\"darkgrey\", border=FALSE) \n</code></pre> </p>"},{"location":"day_3/basic_plots_in_r/#boxplot","title":"Boxplot","text":"<p>Using additional sample information from our metadata, we can use plots to compare values between different factor levels or categories. For example, we can compare the sample means across celltypes 'typeA' and 'typeB' using a boxplot. <pre><code># Boxplot\nboxplot(samplemeans~celltype, data=new_metadata)\n</code></pre> </p>"},{"location":"day_3_exercise/D3.1e_Custom_Functions_ggplot2/","title":"Custom functions for consistent plots","text":"<p>Approximate time: 20 minutes</p>"},{"location":"day_3_exercise/D3.1e_Custom_Functions_ggplot2/#learning-objectives","title":"Learning Objectives","text":"<ul> <li>Apply the custom function to generate consistent plots.</li> </ul>"},{"location":"day_3_exercise/D3.1e_Custom_Functions_ggplot2/#consistent-formatting-using-custom-functions","title":"Consistent formatting using custom functions","text":"<p>When publishing, it is helpful to ensure all plots have similar formatting. To do this we can create a custom function with our preferences for the theme. Remember the structure of a function is:</p> <pre><code>name_of_function &lt;- function(arguments) {\n    statements or code that does something\n}\n</code></pre> <p>Now, let's suppose we always wanted our theme to include the following:</p> <pre><code>theme_bw() +\ntheme(axis.title=element_text(size=rel(1.5))) +\ntheme(plot.title=element_text(size=rel(1.5), hjust=0.5))\n</code></pre> <p>Note</p> <p>You can also combine multiple arguments within the same theme() function: <pre><code>theme_bw() +\ntheme(axis.title=element_text(size=rel(1.5)), plot.title=element_text(size=rel(1.5), hjust=0.5))\n</code></pre></p> <p>If there is nothing that we want to change when we run this, then we do not need to specify any arguments. Creating the function is simple; we can just put the code inside the <code>{}</code>:</p> <pre><code>personal_theme &lt;- function(){\n  theme_bw() +\n  theme(axis.title=element_text(size=rel(1.5))) +\n  theme(plot.title=element_text(size=rel(1.5), hjust=0.5))\n}\n</code></pre> <p>Now to run our personal theme with any plot, we can use this function in place of the lines of <code>theme()</code> code:</p> <pre><code>ggplot(new_metadata) +\n  geom_point(aes(x=age_in_days, y=samplemeans, color=genotype, shape=celltype), size=rel(3.0)) +\n  xlab(\"Age (days)\") +\n  ylab(\"Mean expression\") +\n  ggtitle(\"Expression with Age\") +\n  personal_theme()\n</code></pre> <p>Attribution notice</p> <ul> <li> <p>This lesson has been developed by members of the teaching team at the Harvard Chan Bioinformatics Core (HBC). These are open access materials distributed under the terms of the Creative Commons Attribution license (CC BY 4.0), which permits unrestricted use, distribution, and reproduction in any medium, provided the original author and source are credited.</p> </li> <li> <p>The materials used in this lesson are adapted from work that is Copyright \u00a9 Data Carpentry (http://datacarpentry.org/).</p> </li> <li> <p>All Data Carpentry instructional material is made available under the Creative Commons Attribution license (CC BY 4.0).</p> </li> </ul>"},{"location":"day_3_exercise/D3.2e_boxplot_exercise/","title":"Plotting and data visualization in R","text":"<p>Approximate time: 60 minutes</p>"},{"location":"day_3_exercise/D3.2e_boxplot_exercise/#learning-objectives","title":"Learning Objectives","text":"<ul> <li>Generate the box plot using ggplot2</li> </ul>"},{"location":"day_3_exercise/D3.2e_boxplot_exercise/#generating-a-boxplot-with-ggplot2","title":"Generating a Boxplot with ggplot2","text":"<p>A boxplot provides a graphical view of the distribution of data based on a five number summary:</p> <ul> <li> <p>The top and bottom of the box represent the (1) first and (2) third quartiles (25<sup>th</sup> and 75<sup>th</sup> percentiles, respectively). </p> </li> <li> <p>The line inside the box represents the (3) median (50<sup>th</sup> percentile). </p> </li> <li> <p>The whiskers extending above and below the box represent the (4) maximum, and (5) minimum of a data set. </p> </li> <li> <p>The whiskers of the plot reach the minimum and maximum values that are not outliers. </p> </li> </ul> <p>Note</p> <p>In this case, outliers are determined using the interquartile range (IQR), which is defined as: Q3 - Q1. Any values that exceeds 1.5 x IQR below Q1 or above Q3 are considered outliers and are represented as points above or below the whiskers. </p>"},{"location":"day_3_exercise/D3.2e_boxplot_exercise/#1-boxplot","title":"1. Boxplot!","text":"<p>Generate a boxplot using the data in the new_metadata dataframe. Create a ggplot2 code chunk with the following instructions:</p> <ol> <li>Use the <code>geom_boxplot()</code> layer to plot the differences in sample means between the Wt and KO genotypes.</li> <li>Use the <code>fill</code> aesthetic to look at differences in sample means between the celltypes within each genotype.</li> <li>Add a title to your plot.</li> <li>Add labels, 'Genotype' for the x-axis and 'Mean expression' for the y-axis.</li> <li>Make the following <code>theme()</code> changes:<ul> <li>Use the <code>theme_bw()</code> function to make the background white.</li> <li>Change the size of your axes labels to 1.25x larger than the default.</li> <li>Change the size of your plot title to 1.5x larger than default.</li> <li>Center the plot title.</li> </ul> </li> </ol> <p>After running the above code the boxplot should look something like that provided below.</p> <p> </p>"},{"location":"day_3_exercise/D3.2e_boxplot_exercise/#2-changing-the-order-of-genotype-on-the-boxplot","title":"2. Changing the order of genotype on the Boxplot","text":"<p>Let's say you wanted to have the \"Wt\" boxplots displayed first on the left side, and \"KO\" on the right. How might you go about doing this?</p> <p>To do this, your first question should be: </p> <p>How does ggplot2 determine what to place where on the X-axis?</p> <ul> <li> <p>The order of the genotype on the X axis is in alphabetical order. </p> </li> <li> <p>To change it, you need to make sure that the genotype column is a factor.</p> </li> <li> <p>And, the factor levels for that column are in the order you want on the X-axis</p> </li> <li> <p>Factor the <code>new_metadata$genotype</code> column without creating any extra variables/objects and change the levels to <code>c(\"Wt\", \"KO\")</code></p> </li> <li> <p>Re-run the boxplot code chunk you created for the \"Boxplot!\" exercise above.</p> </li> </ul>"},{"location":"day_3_exercise/D3.2e_boxplot_exercise/#3-changing-default-colors","title":"3. Changing default colors","text":"<p>You can color the boxplot differently by using some specific layers:</p> <ol> <li>Add a new layer <code>scale_color_manual(values=c(\"purple\",\"orange\"))</code>. <ul> <li>Do you observe a change?</li> </ul> </li> <li>Replace <code>scale_color_manual(values=c(\"purple\",\"orange\"))</code> with <code>scale_fill_manual(values=c(\"purple\",\"orange\"))</code>.<ul> <li>Do you observe a change?</li> <li>In the scatterplot we drew in class, add a new layer <code>scale_color_manual(values=c(\"purple\",\"orange\"))</code>, do you observe a difference?</li> <li>What do you think is the difference between <code>scale_color_manual()</code> and <code>scale_fill_manual()</code>?</li> </ul> </li> <li>Back in your boxplot code, change the colors in the <code>scale_fill_manual()</code> layer to be your 2 favorite colors.<ul> <li>Are there any colors that you tried that did not work? </li> </ul> </li> </ol> <p>We have a separate lesson about using color palettes from the package RColorBrewer, if you are interested.</p> <p>You are not restricted to using colors by writing them out as character vectors. You have the choice of a lot of colors in R, and you can do so by using their hexadecimal code. For example, \"#FF0000\" would be red and \"#00FF00\" would be green similarly, <code>#FFFFFF</code> would be white and <code>#000000</code> would be black. click here for more information about color palettes in R.</p> <p>OPTIONAL Exercise:</p> <ul> <li>Find the hexadecimal code for your 2 favourite colors (from exercise 3 above) and replace the color names with the hexadecimal codes within the ggplot2 code chunk.</li> </ul> <p>Attribution notice</p> <ul> <li> <p>This lesson has been developed by members of the teaching team at the Harvard Chan Bioinformatics Core (HBC). These are open access materials distributed under the terms of the Creative Commons Attribution license (CC BY 4.0), which permits unrestricted use, distribution, and reproduction in any medium, provided the original author and source are credited.</p> </li> <li> <p>The materials used in this lesson are adapted from work that is Copyright \u00a9 Data Carpentry (http://datacarpentry.org/).</p> </li> <li> <p>All Data Carpentry instructional material is made available under the Creative Commons Attribution license (CC BY 4.0).</p> </li> </ul>"},{"location":"day_3_exercise/D3.3e_exporting_data_and_plots/","title":"Saving data and plots to file","text":"<p>Approximate time: 30 minutes</p>"},{"location":"day_3_exercise/D3.3e_exporting_data_and_plots/#learning-objectives","title":"Learning Objectives","text":"<ul> <li>Describe how to export data tables and plots for use outside of the R environment.</li> </ul>"},{"location":"day_3_exercise/D3.3e_exporting_data_and_plots/#writing-data-to-file","title":"Writing data to file","text":"<p>Everything we have done so far has only modified the data in R; the files have remained unchanged. Whenever we want to save our datasets to file, we need to use a <code>write</code> function in R. </p> <p>To write our matrix to file in comma separated format (.csv), we can use the <code>write.csv</code> function. There are two required arguments: the variable name of the data structure you are exporting, and the path and filename that you are exporting to. By default the delimiter or column separator is set, and columns will be separated by a comma:</p> <pre><code># Save a data frame to file\nwrite.csv(sub_meta, file=\"data/subset_meta.csv\")\n</code></pre> <p>Oftentimes the output is not exactly what you might want. You can modify the output using the arguments for the function. We can explore the arguments using the <code>?</code>. This can help elucidate what each of the arguments can adjust the output.</p> <pre><code>?write.csv\n</code></pre> <p>Similar to reading in data, there are a wide variety of functions available allowing you to export data in specific formats. Another commonly used function is <code>write.table</code>, which allows you to specify the delimiter or separator you wish to use. This function is commonly used to create tab-delimited files.</p> <p>Note</p> <p>Sometimes when writing a data frame using row names to file with <code>write.table()</code>, the column names will align starting with the row names column. To avoid this, you can include the argument <code>col.names = NA</code> when writing to file to ensure all of the column names line up with the correct column values.</p> <p>Writing a vector of values to file requires a different function than the functions available for writing dataframes. You can use <code>write()</code> to save a vector of values to file. For example:</p> <pre><code># Save a vector to file\nwrite(glengths, file=\"data/genome_lengths.txt\")\n</code></pre> <p>If we wanted the vector to be output to a single column instead of five, we could explore the arguments:</p> <pre><code>?write\n</code></pre> <p>Note, the <code>ncolumns</code> argument that it defaults to five columns unless specified, so to get a single column:</p> <pre><code># Save a vector to file as a single column\nwrite(glengths, file=\"data/genome_lengths.txt\", ncolumns = 1)\n</code></pre>"},{"location":"day_3_exercise/D3.3e_exporting_data_and_plots/#exporting-figures-to-file","title":"Exporting figures to file","text":"<p>There are two ways in which figures and plots can be output to a file (rather than simply displaying on screen). </p> <ol> <li> <p>The first (and easiest) is to export directly from the RStudio 'Plots' panel, by clicking on <code>Export</code> when the image is plotted. This will give you the option of <code>png</code> or <code>pdf</code> and selecting the directory to which you wish to save it to. It will also give you options to dictate the size and resolution of the output image.</p> </li> <li> <p>The second option is to use R functions and have the write to file hard-coded in to your script. This would allow you to run the script from start to finish and automate the process (not requiring human point-and-click actions to save).  In R\u2019s terminology, output is directed to a particular output device and that dictates the output format that will be produced. If we wanted to save our scatterplot to a pdf file format we can use a function called <code>ggsave</code> within <code>ggplot2</code> to help us.</p> </li> </ol> <pre><code>ggplot(new_metadata) +\n  geom_point(aes(x = age_in_days, y= samplemeans, color = genotype,\n            shape=celltype), size=rel(3.0))\nggsave(\"figures/scatterplot.pdf\")\n</code></pre> <p>You can specify the file format you would like it to print to with the <code>device</code> argument. However, <code>ggsave</code> will try to guess your preferred format from the extension that you provide in your file name. </p> <p>By default, <code>ggsave</code> will save the last image that you rendered. If you want to specify the plot to save you can store your image in an object and use the <code>plot</code> argument inside of <code>ggsave</code> to save that specific image.</p> Click here to see how to save an image in base R A device must be created or \u201copened\u201d in order to receive graphical output and, for devices that create a file on disk, the device must also be closed in order to complete the output. If we wanted to print our scatterplot to a pdf file format, we would need to initialize a plot using a function which specifies the graphical format you intend on creating i.e.<code>pdf()</code>, <code>png()</code>, <code>tiff()</code> etc. Within the function you will need to specify a name for your image, and the with and height (optional). This will open up the device that you wish to write to: <pre>\n## Open device for writing\npdf(\"figures/scatterplot.pdf\")\n</pre> If you wish to modify the size and resolution of the image you will need to add in the appropriate parameters as arguments to the function when you initialize. Then we plot the image to the device, using the ggplot scatterplot that we just created. <pre>\n## Make a plot which will be written to the open device, in this case the temp file created by pdf()/png()\nggplot(new_metadata) +\n  geom_point(aes(x = age_in_days, y= samplemeans, color = genotype,\n            shape=celltype), size=rel(3.0)) \n</pre> Finally, close the \"device\", or file, using the <code>dev.off()</code> function. There are also <code>bmp</code>, <code>tiff</code>, and <code>jpeg</code> functions, though the <code>jpeg</code> function has proven less stable than the others. <pre>\n## Closing the device is essential to save the temporary file created by pdf()/png()\ndev.off()\n</pre> <ol><li>You will not be able to open and look at your file using standard methods (Adobe Acrobat or Preview etc.) until you execute the <code>dev.off()</code> function.</li> <li>In the case of <code>pdf()</code>, if you had made additional plots before closing the device, they will all be stored in the same file with each plot usually getting its own page, unless otherwise specified.</li> <p>Attribution notice</p> <ul> <li> <p>This lesson has been developed by members of the teaching team at the Harvard Chan Bioinformatics Core (HBC). These are open access materials distributed under the terms of the Creative Commons Attribution license (CC BY 4.0), which permits unrestricted use, distribution, and reproduction in any medium, provided the original author and source are credited.</p> </li> <li> <p>The materials used in this lesson are adapted from work that is Copyright \u00a9 Data Carpentry (http://datacarpentry.org/).</p> </li> <li> <p>All Data Carpentry instructional material is made available under the Creative Commons Attribution license (CC BY 4.0).</p> </li> </ul>"},{"location":"day_3_exercise/D3.4e_finding_help/","title":"Troubleshooting and finding help","text":"<p>Approximate time: 30 min</p>"},{"location":"day_3_exercise/D3.4e_finding_help/#learning-objectives","title":"Learning Objectives","text":"<ul> <li>Identify different R-specific external sources to help with troubleshooting errors and obtaining more information about functions and packages.</li> </ul>"},{"location":"day_3_exercise/D3.4e_finding_help/#asking-for-help","title":"Asking for help","text":"<p>The key to getting help from someone is for them to grasp your problem rapidly. You should make it as easy as possible to pinpoint where the issue might be.</p> <ol> <li> <p>Try to use the correct words to describe your problem. For instance, a package is not the same thing as a library. Most people will understand what you meant, but others have really strong feelings about the difference in meaning. The key point is that it can make things confusing for people trying to help you. Be as precise as possible when describing your problem.</p> </li> <li> <p>Always include the output of <code>sessionInfo()</code> as it provides critical information about your platform, the versions of R and the packages that you are using, and other information that can be very helpful to understand your problem.</p> <pre><code>sessionInfo()  #This time it is not interchangeable with search()\n</code></pre> </li> <li> <p>If possible, reproduce the problem using a very small <code>data.frame</code> instead of your 50,000 rows and 10,000 columns one, provide the small one with the description of your problem. When appropriate, try to generalize what you are doing so even people who are not in your field can understand the question. </p> <ul> <li> <p>To share an object with someone else, you can provide either the raw file (i.e., your CSV file) with your script up to the point of the error (and after removing everything that is not relevant to your issue). Alternatively, in particular if your questions is not related to a <code>data.frame</code>, you can save any other R data structure that you have in your environment to a file:</p> <p>DO NOT RUN THIS</p> <pre><code># DO NOT RUN THIS!\n\nsave(iris, file=\"/tmp/iris.RData\")\n</code></pre> <p>The content of this <code>.RData</code> file is not human readable and cannot be posted directly on stackoverflow. It can, however, be emailed to someone who can read it with this command:</p> <p>DO NOT RUN THIS</p> <pre><code># DO NOT RUN THIS!\n\nload(file=\"~/Downloads/iris.RData\")\n</code></pre> </li> </ul> </li> </ol>"},{"location":"day_3_exercise/D3.4e_finding_help/#where-to-ask-for-help","title":"Where to ask for help?","text":"<ul> <li>Google is often your best friend for finding answers to specific questions regarding R. <ul> <li>Cryptic error messages are very common in R - it is very likely that someone else has encountered this problem already! Start by googling the error message.  However, this doesn't always work because often, package developers rely on the error catching provided by R. You end up with general error messages that might not be very helpful to diagnose a problem (e.g. \"subscript out of bounds\").</li> </ul> </li> <li>Stackoverflow: Search using the <code>[r]</code> tag. Most questions have already been answered, but the challenge is to use the right words in the search to find the answers: http://stackoverflow.com/questions/tagged/r. If your question hasn't been answered before and is well crafted, chances are you will get an answer in less than 5 min.</li> <li>Your friendly colleagues: if you know someone with more experience than you, they might be able and willing to help you.</li> <li>AI tools: You can submit your line of code and the resulting error to ChatGPT or other tools and ask it to interpret the error for you, or ask ChatGPT to write R code to accomplish the task you are struggling with and see where your solutions differ. Importantly, if you use any code written by AI, make sure you review the generated code line by line to check that it works and that you understand what it is doing!</li> <li>The R-help: it is read by a lot of people (including most of the R core team), a lot of people post to it, but the tone can be pretty dry, and it is not always very welcoming to new users. If your question is valid, you are likely to get an answer very fast but don't expect that it will come with smiley faces. Also, here more than everywhere else, be sure to use correct vocabulary (otherwise you might get an answer pointing to the misuse of your words rather than answering your question). You will also have more success if your question is about a base function rather than a specific package.</li> <li>The Bioconductor support site. This is very useful and if you tag your post, there is a high likelihood of getting an answer from the developer.</li> <li>If your question is about a specific package, see if there is a mailing list for it. Usually it's included in the DESCRIPTION file of the package that can be accessed using <code>packageDescription(\"name-of-package\")</code>. You may also want to try to email the author of the package directly.</li> <li>There are also some topic-specific mailing lists (GIS, phylogenetics, etc...), the complete list is here.</li> </ul>"},{"location":"day_3_exercise/D3.4e_finding_help/#more-resources","title":"More resources","text":"<ul> <li>The Posting Guide for the R mailing lists.</li> <li>How to ask for R help useful guidelines</li> <li>The Introduction to R can also be dense for people with little programming experience but it is a good place to understand the underpinnings of the R language.</li> <li>The R FAQ is dense and technical but it is full of useful information.</li> </ul> <p>Exercise</p> <ol> <li> <p>Run the following code chunks and fix all of the errors. (Note: The code chunks are independent from one another.)</p> <pre><code># Create vector of work days\nwork_days &lt;- c(Monday, Tuesday, Wednesday, Thursday, Friday)\n</code></pre> <pre><code># Create a function to round the output of the sum function\nround_the_sum &lt;- function(x){\n        return(round(sum(x))\n}\n</code></pre> <pre><code># Create a function to add together three numbers\nadd_numbers &lt;- function(x,y,z){\n        sum(x,y,z)\n}\n\nadd_numbers(5,9)\n</code></pre> </li> <li> <p>You try to install a package and you get the following error message:</p> </li> </ol> <p>Error message</p> <pre><code>Error: package or namespace load failed for 'Seurat' in loadNamespace(j &lt;- i[[1L]], c(lib.loc, .libPaths()), versionCheck = vI[[j]]): there is no package called 'multtest'\n</code></pre> <p>What would you do to remedy the error?</p> <ol> <li> <p>You would like to ask for help on an online forum. To do this you want the users of the forum to reproduce your problem, so you want to provide them as much relevant information and data as possible.</p> <ul> <li>You want to provide them with the list of packages that you currently have loaded, the version of R, your OS and package versions. Use the appropriate function(s) to obtain this information.</li> <li>You want to also provide a small data frame that reproduces the error (if working with a large data frame, you'll need to subset it down to something small). For this exercise use the data frame <code>df</code>, and save it as an RData object called <code>df.RData</code>. </li> <li>What code should the people looking at your help request should use to read in <code>df.RData</code>?</li> </ul> </li> </ol> <p>Attribution notice</p> <ul> <li> <p>This lesson has been developed by members of the teaching team at the Harvard Chan Bioinformatics Core (HBC). These are open access materials distributed under the terms of the Creative Commons Attribution license (CC BY 4.0), which permits unrestricted use, distribution, and reproduction in any medium, provided the original author and source are credited.</p> </li> <li> <p>The materials used in this lesson are adapted from work that is Copyright \u00a9 Data Carpentry (http://datacarpentry.org/).</p> </li> <li> <p>All Data Carpentry instructional material is made available under the Creative Commons Attribution license (CC BY 4.0).</p> </li> </ul>"},{"location":"day_3_exercise/D3.5e_tidyverse/","title":"Tidyverse data wrangling","text":"<p>Approximate time: 75 minutes</p>"},{"location":"day_3_exercise/D3.5e_tidyverse/#learning-objectives","title":"Learning Objectives","text":"<ul> <li>Perform basic data wrangling with functions in the Tidyverse package.</li> </ul>"},{"location":"day_3_exercise/D3.5e_tidyverse/#data-wrangling-with-tidyverse","title":"Data Wrangling with Tidyverse","text":"<p>The Tidyverse suite of integrated packages are designed to work together to make common data science operations more user friendly. The packages have functions for data wrangling, tidying, reading/writing, parsing, and visualizing, among others. There is a freely available book, R for Data Science, with detailed descriptions and practical examples of the tools available and how they work together. We will explore the basic syntax for working with these packages, as well as, specific functions for data wrangling with the 'dplyr' package and data visualization with the 'ggplot2' package.</p> <p> </p>"},{"location":"day_3_exercise/D3.5e_tidyverse/#tidyverse-basics","title":"Tidyverse basics","text":"<p>The Tidyverse suite of packages introduces users to a set of data structures, functions and operators to make working with data more intuitive, but is slightly different from the way we do things in base R. Two important new concepts we will focus on are pipes and tibbles.</p> <p>Before we get started with pipes or tibbles, let's load the library:</p> <pre><code>library(tidyverse)\n</code></pre>"},{"location":"day_3_exercise/D3.5e_tidyverse/#pipes","title":"Pipes","text":"<p>Stringing together commands in R can be quite daunting. Also, trying to understand code that has many nested functions can be confusing. </p> <p>To make R code more human readable, the Tidyverse tools use the pipe, <code>%&gt;%</code>, which was acquired from the <code>magrittr</code> package and is now part of the <code>dplyr</code> package that is installed automatically with Tidyverse. The pipe allows the output of a previous command to be used as input to another command instead of using nested functions.</p> <p>Note</p> <p>Shortcut to write the pipe is shift + command + M</p> <p>An example of using the pipe to run multiple commands:</p> <pre><code>## A single command\nsqrt(83)\n\n## Base R method of running more than one command\nround(sqrt(83), digits = 2)\n\n## Running more than one command with piping\nsqrt(83) %&gt;% round(digits = 2)\n</code></pre> <p>The pipe represents a much easier way of writing and deciphering R code, and so we will be taking advantage of it, when possible, as we work through the remaining lesson.</p> <p>Exercise</p> <ol> <li> <p>Create a vector of random numbers using the code below:</p> <pre><code>random_numbers &lt;- c(81, 90, 65, 43, 71, 29)\n</code></pre> </li> <li> <p>Use the pipe (<code>%&gt;%</code>) to perform two steps in a single line:</p> <ul> <li>Take the mean of <code>random_numbers</code> using the <code>mean()</code> function.</li> <li>Round the output to three digits using the <code>round()</code> function.</li> </ul> </li> </ol>"},{"location":"day_3_exercise/D3.5e_tidyverse/#tibbles","title":"Tibbles","text":"<p>A core component of the tidyverse is the tibble. Tibbles are a modern rework of the standard <code>data.frame</code>, with some internal improvements to make code more reliable.  They are data frames, but do not follow all of the same rules. For example, tibbles can have numbers/symbols for column names, which is not normally allowed in base R. </p> <p>Important: tidyverse is very opininated about row names. These packages insist that all column data (e.g. <code>data.frame</code>) be treated equally, and that special designation of a column as <code>rownames</code> should be deprecated. Tibble provides simple utility functions to handle rownames: <code>rownames_to_column()</code> and <code>column_to_rownames()</code>. </p> <p>Tibbles can be created directly using the <code>tibble()</code> function or data frames can be converted into tibbles using <code>as_tibble(name_of_df)</code>. </p> <p>Note</p> <p>The function <code>as_tibble()</code> will ignore row names, so if a column representing the row names is needed, then the function <code>rownames_to_column(name_of_df)</code> should be run prior to turning the data.frame into a tibble. Also, <code>as_tibble()</code> will not coerce character vectors to factors by default.</p>"},{"location":"day_3_exercise/D3.5e_tidyverse/#experimental-data","title":"Experimental data","text":"<p>We're going to explore the Tidyverse suite of tools to wrangle our data to prepare it for visualization. You should have downloaded the file called <code>gprofiler_results_Mov10oe.tsv</code> into your R project's <code>data</code> folder earlier. </p> <p>Note</p> <p>If you do not have the <code>gprofiler_results_Mov10oe.tsv</code> file in your <code>data</code> folder, you can right click and download it into the <code>data</code> folder using this link.</p> <p>The dataset:</p> <ul> <li>Represents the functional analysis results, including the biological processes, functions, pathways, or conditions that are over-represented in a given list of genes.</li> <li>Our gene list was generated by differential gene expression analysis and the genes represent differences between control mice and mice over-expressing a gene involved in RNA splicing. </li> </ul> <p>The functional analysis that we will focus on involves gene ontology (GO) terms, which:</p> <ul> <li>describe the roles of genes and gene products</li> <li>organized into three controlled vocabularies/ontologies (domains):<ul> <li>biological processes (BP)</li> <li>cellular components (CC)</li> <li>molecular functions (MF)</li> </ul> </li> </ul> <p> </p>"},{"location":"day_3_exercise/D3.5e_tidyverse/#analysis-goal-and-workflow","title":"Analysis goal and workflow","text":"<p>Goal: Visually compare the most significant biological processes (BP) based on the number of associated differentially expressed genes (gene ratios) and significance values by creating the following plot:</p> <p> </p> <p>To wrangle our data in preparation for the plotting, we are going to use the Tidyverse suite of tools to wrangle and visualize our data through several steps:</p> <ol> <li>Read in the functional analysis results</li> <li>Extract only the GO biological processes (BP) of interest</li> <li>Select only the columns needed for visualization</li> <li>Order by significance (p-adjusted values)</li> <li>Rename columns to be more intuitive</li> <li>Create additional metrics for plotting (e.g. gene ratios)</li> <li>Plot results</li> </ol>"},{"location":"day_3_exercise/D3.5e_tidyverse/#tidyverse-tools","title":"Tidyverse tools","text":"<p>While all of the tools in the Tidyverse suite are deserving of being explored in more depth, we are going to investigate more deeply the reading (<code>readr</code>), wrangling (<code>dplyr</code>), and plotting (<code>ggplot2</code>) tools.</p>"},{"location":"day_3_exercise/D3.5e_tidyverse/#1-read-in-the-functional-analysis-results","title":"1. Read in the functional analysis results","text":"<p>While the base R packages have perfectly fine methods for reading in data, the <code>readr</code> and <code>readxl</code> Tidyverse packages offer additional methods for reading in data. Let's read in our tab-delimited functional analysis results using <code>read_delim()</code>:</p> <pre><code># Read in the functional analysis results\nfunctional_GO_results &lt;- read_delim(file = \"data/gprofiler_results_Mov10oe.tsv\", delim = \"\\t\" )\n\n# Take a look at the results\nfunctional_GO_results\n</code></pre> Click here to see how to do this in base R <p>Read in the functional analysis results <pre><code>functional_GO_results &lt;- read.delim(file = \"data/gprofiler_results_Mov10oe.tsv\", sep = \"\\t\" )\n</code></pre> Take a look at the results <pre><code>functional_GO_results\n</code></pre></p> <p>Notice that the results were automatically read in as a tibble and the output gives the number of rows, columns and the data type for each of the columns.</p> <p>Note</p> <p>A large number of tidyverse functions will work with both tibbles and dataframes, and the data structure of the output will be identical to the input. However, there are some functions that will return a tibble (without row names), whether or not a tibble or dataframe is provided.</p>"},{"location":"day_3_exercise/D3.5e_tidyverse/#2-extract-only-the-go-biological-processes-bp-of-interest","title":"2. Extract only the GO biological processes (BP) of interest","text":"<p>Now that we have our data, we will need to wrangle it into a format ready for plotting. For all of our data wrangling steps we will be using tools from the dplyr package, which is a swiss-army knife for data wrangling of data frames. </p> <p>To extract the biological processes of interest, we only want those rows where the <code>domain</code> is equal to <code>BP</code>, which we can do using the <code>filter()</code> function. </p> <p>To filter rows of a data frame/tibble based on values in different columns, we give a logical expression as input to the <code>filter()</code> function to return those rows for which the expression is TRUE.</p> <p>Now let's return only those rows that have a <code>domain</code> of <code>BP</code>:</p> <pre><code># Return only GO biological processes\nbp_oe &lt;- functional_GO_results %&gt;%\n  filter(domain == \"BP\")\n\nView(bp_oe)\n</code></pre> Click here to see how to do this in base R <p>Return only GO biological processes</p> <pre><code>idx &lt;- functional_GO_results$domain == \"BP\"\nbp_oe2 &lt;- functional_GO_results[idx,]\n\nView(bp_oe)\n</code></pre> <p>Now we have returned only those rows with a <code>domain</code> of <code>BP</code>. How have the dimensions of our results changed?</p> <p>Exercise</p> <p>We would like to perform an additional round of filtering to only keep the most specific GO terms. </p> <ol> <li>For <code>bp_oe</code>, use the <code>filter()</code> function to only keep those rows where the <code>relative.depth</code> is greater than 4.</li> <li>Save output to overwrite our <code>bp_oe</code> variable.</li> </ol>"},{"location":"day_3_exercise/D3.5e_tidyverse/#3-select-only-the-columns-needed-for-visualization","title":"3. Select only the columns needed for visualization","text":"<p>For visualization purposes, we are only interested in the columns related to the GO terms, the significance of the terms, and information about the number of genes associated with the terms. </p> <p>To extract columns from a data frame/tibble we can use the <code>select()</code> function. In contrast to base R, we do not need to put the column names in quotes for selection.</p> <pre><code># Selecting columns to keep\nbp_oe &lt;- bp_oe %&gt;%\n  select(term.id, term.name, p.value, query.size, term.size, overlap.size, intersection)\n\nView(bp_oe)\n</code></pre> Click here to see how to do this in base R <p>Selecting columns to keep <pre><code>bp_oe &lt;- bp_oe[, c(\"term.id\", \"term.name\", \"p.value\", \"query.size\", \"term.size\", \"overlap.size\", \"intersection\")]\n\nView(bp_oe)\n</code></pre></p> <p>The <code>select()</code> function also allows for negative selection. So we could have alternately removed columns with negative selection. Note that we need to put the column names inside of the combine (<code>c()</code>) function with a <code>-</code> preceding it for this functionality.</p> <p>DO NOT RUN</p> <pre><code># DO NOT RUN\n# Selecting columns to remove\nbp_oe &lt;- bp_oe %&gt;%\n    select(-c(query.number, significant, recall, precision, subgraph.number, relative.depth, domain))\n</code></pre> Click here to see how to do this in base R <p>DO NOT RUN</p> <pre><code>#Selecting columns to remove\nidx &lt;- !(colnames(bp_oe) %in% c(\"query.number\", \"significant\", \"recall\", \"precision\", \"subgraph.number\", \"relative.depth\", \"domain\"))\nbp_oe &lt;- bp_oe[, idx]&lt;/code&gt;&lt;/pre&gt;&lt;br&gt;\n</code></pre> <p> </p>"},{"location":"day_3_exercise/D3.5e_tidyverse/#4-order-go-processes-by-significance-adjusted-p-values","title":"4. Order GO processes by significance (adjusted p-values)","text":"<p>Now that we have only the rows and columns of interest, let's arrange these by significance, which is denoted by the adjusted p-value.</p> <p>Let's sort the rows by adjusted p-value with the <code>arrange()</code> function.</p> <pre><code># Order by adjusted p-value ascending\nbp_oe &lt;- bp_oe %&gt;%\n  arrange(p.value)\n</code></pre> Click here to see how to do this in base R <p>Order by adjusted p-value ascending <pre><code>idx &lt;- order(bp_oe$p.value)\nbp_oe &lt;- bp_oe[idx,]\n</code></pre></p> <p>Note</p> <p>If you wanted to arrange in descending order, then you could have run the following instead:</p> <p>DO NOT RUN</p> <pre><code># DO NOT RUN\n# Order by adjusted p-value descending\nbp_oe &lt;- bp_oe %&gt;%\narrange(desc(p.value))\n</code></pre> Click here to see how to do this in base R <p>DO NOT RUN</p> <pre><code># Do not run\n# Order by adjusted p-value descending\nidx &lt;- order(bp_oe$p.value, decreasing = TRUE)\nbp_oe &lt;- bp_oe[idx,]\n</code></pre> <p>Note</p> <p>Ordering variables in <code>ggplot2</code> is a bit different. This post introduces a few ways of ordering variables in a plot.</p>"},{"location":"day_3_exercise/D3.5e_tidyverse/#5-rename-columns-to-be-more-intuitive","title":"5. Rename columns to be more intuitive","text":"<p>While not necessary for our visualization, renaming columns more intuitively can help with our understanding of the data using the <code>rename()</code> function. The syntax is <code>new_name</code> = <code>old_name</code>.</p> <p>Let's rename the <code>term.id</code> and <code>term.name</code> columns.</p> <pre><code># Provide better names for columns\nbp_oe &lt;- bp_oe %&gt;% \n  dplyr::rename(GO_id = term.id, \n                GO_term = term.name)\n</code></pre> Click here to see how to do this in base R <pre><code># Provide better names for columns\ncolnames(bp_oe)[colnames(bp_oe) == \"term.id\"] &lt;- \"GO_id\"\ncolnames(bp_oe)[colnames(bp_oe) == \"term.name\"] &lt;- \"GO_term\"\n</code></pre> <p>Note</p> <p>In the case of two packages with identical function names, you can use <code>::</code> with the package name before and the function name after (e.g <code>stats::filter()</code>) to ensure that the correct function is implemented. The <code>::</code> can also be used to bring in a function from a library without loading it first.</p> <p>In the example above, we wanted to use the <code>rename()</code> function specifically from the <code>dplyr</code> package, and not any of the other packages (or base R) which may have the <code>rename()</code> function.</p> <p>Exercise</p> <p>Rename the <code>intersection</code> column to <code>genes</code> to reflect the fact that these are the DE genes associated with the GO process.</p>"},{"location":"day_3_exercise/D3.5e_tidyverse/#6-create-additional-metrics-for-plotting-eg-gene-ratios","title":"6. Create additional metrics for plotting (e.g. gene ratios)","text":"<p>Finally, before we plot our data, we need to create a couple of additional metrics. The <code>mutate()</code> function enables you to create a new column from an existing column. </p> <p>Let's generate gene ratios to reflect the number of DE genes associated with each GO process relative to the total number of DE genes.</p> <pre><code># Create gene ratio column based on other columns in dataset\nbp_oe &lt;- bp_oe %&gt;%\n  mutate(gene_ratio = overlap.size / query.size)\n</code></pre> Click here to see how to do this in base R <pre><code># Create gene ratio column based on other columns in dataset\nbp_oe &lt;- cbind(bp_oe, gene_ratio = bp_oe$overlap.size / bp_oe$query.size)\n</code></pre> <p>Exercise</p> <p>Create a column in <code>bp_oe</code> called <code>term_percent</code> to determine the percent of DE genes associated with the GO term relative to the total number of genes associated with the GO term (<code>overlap.size</code> / <code>term.size</code>)</p> <p>Our final data for plotting should look like the table below:</p> <p> </p>"},{"location":"day_3_exercise/D3.5e_tidyverse/#next-steps","title":"Next steps","text":"<p>Now that we have our results ready for plotting, we can use the ggplot2 package to plot our results. If you are interested, you can follow this lesson and dive into how to use <code>ggplot2</code> to create the plots with this dataset.</p>"},{"location":"day_3_exercise/D3.5e_tidyverse/#additional-resources","title":"Additional resources","text":"<ul> <li>R for Data Science</li> <li>teach the tidyverse</li> <li>tidy style guide</li> </ul> <p>Attribution notice</p> <ul> <li> <p>This lesson has been developed by members of the teaching team at the Harvard Chan Bioinformatics Core (HBC). These are open access materials distributed under the terms of the Creative Commons Attribution license (CC BY 4.0), which permits unrestricted use, distribution, and reproduction in any medium, provided the original author and source are credited.</p> </li> <li> <p>The materials used in this lesson are adapted from work that is Copyright \u00a9 Data Carpentry (http://datacarpentry.org/).</p> </li> <li> <p>All Data Carpentry instructional material is made available under the Creative Commons Attribution license (CC BY 4.0).</p> </li> </ul>"},{"location":"day_4/D4.1_in_class_exercises/","title":"Day 4 Activities","text":"<ol> <li> <p>Change the <code>animals</code> data frame to a tibble called <code>animals_tb</code>. Save the row names to a column called <code>animal_names</code> before turning it into a tibble.  </p> </li> <li> <p>Use ggplot2 to plot the animal names (x-axis) versus the speed of the animal (y-axis) in <code>animals_tb</code> using a scatterplot. Customize the plot to display as shown below.  </p> </li> <li> <p>We decide that our plot would look better with the animal names ordered from slowest to fastest. Using the <code>animals_tb</code> tibble, reorder the animals on the x-axis to start with the slowest animal on the left-hand side of the plot to the fastest animal on the right-hand side of the plot by completing the following steps:</p> <p>a. Use the <code>arrange()</code> function to order the rows by speed from slowest to fastest. Then use the <code>pull()</code> function to extract the <code>animal_names</code> column as a vector of character values. Save the new variable as <code>names_ordered_by_speed</code>.</p> <p>b. Turn the <code>animal_names</code> column of <code>animals_tb</code> into a factor and specify the levels as <code>names_ordered_by_speed</code> from slowest to fastest (output in part a). Note: this step is crucial, because ggplot2 uses <code>factor</code> as plotting order, instead of the order we observe in data frame.</p> <p>c. Re-plot the scatterplot with the animal names in order from slowest to fastest.  </p> <p>Note</p> <p>If you are interested in exploring other ways to reorder a variable in ggplot2, refer to this post.</p> </li> <li> <p>Save the plot as a PDF called <code>animals_by_speed_scatterplot.pdf</code> to the <code>results</code> folder.</p> </li> <li> <p>Use the functions from the <code>dplyr</code> package to perform the following tasks:</p> <p>a. Extract the rows of <code>animals_tb</code> tibble with color of gray or tan, order the rows based from slowest to fastest speed, and save to a variable called <code>animals_gray_tan</code>.  b. Save <code>animals_gray_tan</code> as a comma-separated value file called <code>animals_tb_ordered.csv</code> to the <code>results</code> folder. </p> </li> </ol> <p>Attribution notice</p> <ul> <li> <p>This lesson has been developed by members of the teaching team at the Harvard Chan Bioinformatics Core (HBC). These are open access materials distributed under the terms of the Creative Commons Attribution license (CC BY 4.0), which permits unrestricted use, distribution, and reproduction in any medium, provided the original author and source are credited.</p> </li> <li> <p>The materials used in this lesson are adapted from work that is Copyright \u00a9 Data Carpentry (http://datacarpentry.org/).</p> </li> <li> <p>All Data Carpentry instructional material is made available under the Creative Commons Attribution license (CC BY 4.0).</p> </li> </ul>"},{"location":"day_4_exercise_n_answer_keys/D4.1e_intro_to_R_hw/","title":"Introduction to R practice","text":""},{"location":"day_4_exercise_n_answer_keys/D4.1e_intro_to_R_hw/#creating-vectorsfactors-and-dataframes","title":"Creating vectors/factors and dataframes","text":"<ol> <li> <p>We are performing RNA-Seq on cancer samples being treated with three different types of treatment (A, B, and P). You have 12 samples total, with 4 replicates per treatment. Write the R code you would use to construct your metadata table as described below.  </p> <ul> <li>Create the vectors/factors for each column (Hint: you can type out each vector/factor, or if you want the process go faster try exploring the <code>rep()</code> function).</li> <li>Put them together into a dataframe called <code>meta</code>.</li> <li>Use the <code>rownames()</code> function to assign row names to the dataframe (Hint: you can type out the row names as a vector, or if you want the process go faster try exploring the <code>paste()</code> function).</li> </ul> <p>Your finished metadata table should have information for the variables <code>sex</code>, <code>stage</code>, <code>treatment</code>, and <code>myc</code> levels: </p> sex stage treatment myc sample1 M I A 2343 sample2 F II A 457 sample3 M II A 4593 sample4 F I A 9035 sample5 M II B 3450 sample6 F II B 3524 sample7 M I B 958 sample8 F II B 1053 sample9 M II P 8674 sample10 F I P 3424 sample11 M II P 463 sample12 F II P 5105 </li> </ol>"},{"location":"day_4_exercise_n_answer_keys/D4.1e_intro_to_R_hw/#subsetting-vectorsfactors-and-dataframes","title":"Subsetting vectors/factors and dataframes","text":"<ol> <li> <p>Using the <code>meta</code> data frame from question #1, write out the R code you would use to perform the following operations (questions DO NOT build upon each other):</p> <ul> <li>return only the <code>treatment</code> and <code>sex</code> columns using <code>[]</code>:</li> <li>return the <code>treatment</code> values for samples 5, 7, 9, and 10 using <code>[]</code>:</li> <li>use <code>filter()</code> to return all data for those samples receiving treatment <code>P</code>:</li> <li>use <code>filter()</code>/<code>select()</code>to return only the <code>stage</code> and <code>treatment</code> columns for those samples with <code>myc</code> &gt; 5000:</li> <li>remove the <code>treatment</code> column from the dataset using <code>[]</code>:</li> <li>remove samples 7, 8 and 9 from the dataset using <code>[]</code>:</li> <li>keep only samples 1-6 using <code>[]</code>:</li> <li>add a column called <code>pre_treatment</code> to the beginning of the dataframe with the values T, F, F, F, T, T, F, T, F, F, T, T (Hint: use <code>cbind()</code>): </li> <li>change the names of the columns to: \"A\", \"B\", \"C\", \"D\":</li> </ul> </li> </ol>"},{"location":"day_4_exercise_n_answer_keys/D4.1e_intro_to_R_hw/#extracting-components-from-lists","title":"Extracting components from lists","text":"<ol> <li>Create a new list, <code>list_hw</code> with three components, the <code>glengths</code> vector, the dataframe <code>df</code>, and <code>number</code> value. Use this list to answer the questions below . <code>list_hw</code> has the following structure (NOTE: the components of this list are not currently named): <pre><code>[[1]]\n[1]   4.6  3000.0 50000.0 \n\n[[2]]\n     species  glengths \n1    ecoli    4.6\n2    human    3000.0\n3    corn     50000.0\n\n[[3]]\n[1] 8\n</code></pre> Write out the R code you would use to perform the following operations (questions DO NOT build upon each other):</li> <li>return the second component of the list:</li> <li>return <code>50000.0</code> from the first component of the list:</li> <li>return the value <code>human</code> from the second component: </li> <li>give the components of the list the following names: \"genome_lengths\", \"genomes\", \"record\":</li> </ol>"},{"location":"day_4_exercise_n_answer_keys/D4.1e_intro_to_R_hw/#creating-figures-with-ggplot2","title":"Creating figures with ggplot2","text":"<ol> <li> <p>Create the same plot as above using ggplot2 using the provided metadata and counts datasets. The metadata table describes an experiment that you have setup for RNA-seq analysis, while the associated count matrix gives the normalized counts for each sample for every gene. Download the count matrix and metadata using the links provided.</p> <p>Follow the instructions below to build your plot. Write the code you used and provide the final image.</p> <ul> <li> <p>Read in the metadata file using: <code>meta &lt;- read.delim(\"Mov10_full_meta.txt\", sep=\"\\t\", row.names=1)</code></p> </li> <li> <p>Read in the count matrix file using: <code>data &lt;- read.delim(\"normalized_counts.txt\", sep=\"\\t\", row.names=1)</code></p> </li> <li> <p>Create a vector called <code>expression</code> that contains the normalized count values from the row in normalized_counts that corresponds to the MOV10 gene.  </p> </li> <li> <p>Check the class of this expression vector. Then, convert it to a numeric vector using <code>as.numeric(expression)</code></p> </li> <li> <p>Bind that vector to your metadata data frame (<code>meta</code>) and call the new data frame <code>df</code>. </p> </li> <li> <p>Create a ggplot by constructing the plot line by line:</p> <ul> <li> <p>Initialize a  ggplot with your <code>df</code> as input.</p> </li> <li> <p>Add the <code>geom_jitter()</code> geometric object with the required aesthetics which are x and y.</p> </li> <li> <p>Color the points based on <code>sampletype</code></p> </li> <li> <p>Add the <code>theme_bw()</code> layer </p> </li> <li> <p>Add the title \"Expression of MOV10\" to the plot</p> </li> <li> <p>Change the x-axis label to be blank</p> </li> <li> <p>Change the y-axis label to \"Normalized counts\"</p> </li> <li> <p>Using <code>theme()</code> change the following properties of the plot:</p> <ul> <li> <p>Remove the legend (Hint: use ?theme help and scroll down to legend.position)</p> </li> <li> <p>Change the plot title size to 1.5x the default and center align</p> </li> <li> <p>Change the axis title to 1.5x the default size</p> </li> <li> <p>Change the size of the axis text only on the y-axis to 1.25x the default size</p> </li> <li> <p>Rotate the x-axis text to 45 degrees using <code>axis.text.x=element_text(angle=45, hjust=1)</code></p> </li> </ul> </li> </ul> </li> </ul> </li> </ol> <p>Attribution notice</p> <ul> <li> <p>This lesson has been developed by members of the teaching team at the Harvard Chan Bioinformatics Core (HBC). These are open access materials distributed under the terms of the Creative Commons Attribution license (CC BY 4.0), which permits unrestricted use, distribution, and reproduction in any medium, provided the original author and source are credited.</p> </li> <li> <p>The materials used in this lesson are adapted from work that is Copyright \u00a9 Data Carpentry (http://datacarpentry.org/).</p> </li> <li> <p>All Data Carpentry instructional material is made available under the Creative Commons Attribution license (CC BY 4.0).</p> </li> </ul>"},{"location":"day_4_exercise_n_answer_keys/Day1_Homework_Answer-Key/","title":"Day1 Homework Answer Key","text":""},{"location":"day_4_exercise_n_answer_keys/Day1_Homework_Answer-Key/#day-1-homework-exercises","title":"Day 1 Homework Exercises","text":""},{"location":"day_4_exercise_n_answer_keys/Day1_Homework_Answer-Key/#r-syntax-and-data-structures","title":"R syntax and data structures","text":"<pre><code># 1. Try changing the value of the variable `x` to 5. What happens to `number`?\n\nx &lt;- 5\n\n# 2. Now try changing the value of variable `y` to contain the value 10. What do you need to do, to update the variable `number`?\n\ny &lt;- 10\n\nnumber &lt;- x + y\n\n#3. Try to create a vector of numeric and character values by combining the two vectors that we just created (`glengths` and `species`). Assign this combined vector to a new variable called `combined`. \n\n## Hint: you will need to use the combine `c()` function to do this. Print the `combined` vector in the console, what looks different compared to the original vectors?\n\ncombined &lt;- c(glengths, species)\n\n#4. Let's say that in our experimental analyses, we are working with three different sets of cells: normal, cells knocked out for geneA (a very exciting gene), and cells overexpressing geneA. We have three replicates for each celltype.\n\n## a. Create a vector named `samplegroup` with nine elements: 3 control (\"CTL\") values, 3 knock-out (\"KO\") values, and 3 over-expressing (\"OE\") values.\n\nsamplegroup &lt;- c(\"CTL\", \"CTL\", \"CTL\", \"KO\", \"KO\", \"KO\", \"OE\", \"OE\", \"OE\")\n\n## b. Turn `samplegroup` into a factor data structure.\n\nsamplegroup &lt;- factor(samplegroup)\n\n# 5. Create a data frame called `favorite_books` with the following vectors as columns:\n\ntitles &lt;- c(\"Catch-22\", \"Pride and Prejudice\", \"Nineteen Eighty Four\")\npages &lt;- c(453, 432, 328)\nfavorite_books &lt;- data.frame(titles, pages)\n\n# 6. Create a list called `list2` containing `species`, `glengths`, and `number`.\nlist2 &lt;- list(species, glengths, number)\n</code></pre>"},{"location":"day_4_exercise_n_answer_keys/Day1_Homework_Answer-Key/#functions-and-arguments","title":"Functions and arguments","text":"<pre><code># 1. Let's use base R function to calculate **mean** value of the `glengths` vector. You might need to search online to find what function can perform this task.\nmean(glengths)\n\n# 2. Create a new vector `test &lt;- c(1, NA, 2, 3, NA, 4)`. Use the same base R function from exercise 1 (with addition of proper argument), and calculate mean value of the `test` vector. The output should be `2.5`.\n#   *NOTE:* In R, missing values are represented by the symbol `NA` (not available). It\u2019s a way to make sure that users know they have missing data, and make a conscious decision on how to deal with it. There are ways to ignore `NA` during statistical calculations, or to remove `NA` from the vector. More information related to missing data can be found at this link -&gt; https://www.statmethods.net/input/missingdata.html.\ntest &lt;- c(1, NA, 2, 3, NA, 4)\nmean(test, na.rm=TRUE)\n\n# 3. Another commonly used base function is `sort()`. Use this function to sort the `glengths` vector in **descending** order.\nsort(glengths, decreasing = TRUE)\n\n# 4. Write a function called `multiply_it`, which takes two inputs: a numeric value `x`, and a numeric value `y`. The function will return the product of these two numeric values, which is `x * y`. For example, `multiply_it(x=4, y=6)` will return output `24`.\nmultiply_it &lt;- function(x,y) {\n  product &lt;- x * y\n  return(product)\n}\n</code></pre>"},{"location":"day_4_exercise_n_answer_keys/Day1_Homework_Answer-Key/#reading-in-and-inspecting-data","title":"Reading in and inspecting data","text":"<pre><code># 1. Download this tab-delimited .txt file and save it in your project\u2019s data folder.\n#       i. Read it in to R using read.table() and store it as the variable proj_summary, keeping in mind that: \n#               a. all the columns have column names \n#               b. you want the first column to be used as rownames (hint: look up the row.names = argument)\n#       ii. Display the contents of proj_summary in your console\nproj_summary &lt;- read.table(file = \"data/project-summary.txt\", header = TRUE, row.names = 1)\n\n# 2. Use the class() function on glengths and metadata, how does the output differ between the two?\nclass(glengths)\nclass(metadata)\n\n# 3. Use the summary() function on the proj_summary dataframe\n#       i. What is the median rRNA_rate?\n#       ii. How many samples got the \u201clow\u201d level of treatment\nsummary(proj_summary)\n\n# 4. How long is the samplegroup factor?\nlength(samplegroup)\n\n# 5. What are the dimensions of the proj_summary dataframe?\ndim(proj_summary)\n\n# 6. When you use the rownames() function on metadata, what is the data structure of the output?\nstr(rownames(metadata))\n\n# 7. How many elements in (how long is) the output of colnames(proj_summary)? Don\u2019t count, but use another function to determine this.\nlength(colnames(proj_summary))\n</code></pre> <p>Attribution notice</p> <ul> <li> <p>This lesson has been developed by members of the teaching team at the Harvard Chan Bioinformatics Core (HBC). These are open access materials distributed under the terms of the Creative Commons Attribution license (CC BY 4.0), which permits unrestricted use, distribution, and reproduction in any medium, provided the original author and source are credited.</p> </li> <li> <p>The materials used in this lesson are adapted from work that is Copyright \u00a9 Data Carpentry (http://datacarpentry.org/).</p> </li> <li> <p>All Data Carpentry instructional material is made available under the Creative Commons Attribution license (CC BY 4.0).</p> </li> </ul>"},{"location":"day_4_exercise_n_answer_keys/Day2_Homework_Answer-Key/","title":"Day2 Homework Answer Key","text":""},{"location":"day_4_exercise_n_answer_keys/Day2_Homework_Answer-Key/#day-2-homework-exercises","title":"Day 2 Homework Exercises","text":""},{"location":"day_4_exercise_n_answer_keys/Day2_Homework_Answer-Key/#data-wrangling","title":"Data wrangling","text":"<pre><code># 1. Extract only those elements in `samplegroup` that are not KO (*nesting the logical operation is optional*).\nidx &lt;- samplegroup != \"KO\"\nsamplegroup[idx]\n\n# 2. Use the `samplegroup` factor we created in a previous lesson, and relevel it such that KO is the first level followed by CTL and OE.\nfactor(samplegroup, levels = c(\"KO\", \"CTL\", \"OE\"))\n\n### Packages and Libraries\n\n# 1. Install the tidyverse package (it is actually a suite of packages). NOTE: This suite of packages is only available in CRAN.\ninstall.packages(\"tidyverse\")\n\n# 2. Load the tidyverse library. Do you see anything unusual when it loads?\nlibrary(tidyverse)\n#Some functions from dyplyr (part of tidyverse package) mask the same functions from the basic stats. But that is fine! If you need to use filter function from stats, you can type 'stats::filter()'\n\n# 3. Run sessionInfo().\nsessionInfo()\n</code></pre>"},{"location":"day_4_exercise_n_answer_keys/Day2_Homework_Answer-Key/#data-wrangling-data-frames-matrices-and-lists","title":"Data wrangling: data frames, matrices, and lists","text":"<pre><code># 1. Return the genotype and replicate column values for Sample2 and Sample8.\nmetadata[c(\"sample2\", \"sample8\"), c(\"genotype\", \"replicate\")] # or\nmetadata[c(2,8), c(1,3)]\n\n# 2. Return the fourth and ninth values of the replicate column.\nmetadata$replicate[c(4,9)] # or\nmetadata[c(4, 9), \"replicate\"]\n\n# 3. Extract the replicate column as a data frame.\nmetadata[, \"replicate\", drop = FALSE]\n\n# 4. Subset the metadata dataframe to return only the rows of data with a genotype of KO.\nidx &lt;- which(metadata$genotype==\"KO\")\nmetadata[idx, ]\n\n# 5. Create a list named random with the following components: metadata, age, list1, samplegroup, and number.\nrandom &lt;- list(metadata, age, list1, samplegroup, number)\n\n# 6. Extract the samplegroup component.\nrandom[[4]]\n\n# 7. Set names for the random list you created in the last exercise.\nnames(random) &lt;- c(\"metadata\", \"age\", \"list1\", \"samplegroup\", \"number\")\n\n# 8. Extract the age component using the $ notation\nrandom$age\n</code></pre>"},{"location":"day_4_exercise_n_answer_keys/Day2_Homework_Answer-Key/#the-in-operator","title":"The %in% operator","text":"<pre><code># 1. Using the A and B vectors created above, evaluate each element in B to see if there is a match in A\nB %in% A\n\n# 2. Subset the B vector to only return those values that are also in A.\nB[B %in% A]\n\n# 3. We have a list of 6 marker genes that we are very interested in. Our goal is to extract count data for these genes using the %in% operator from the rpkm_data data frame, instead of scrolling through rpkm_data and finding them manually.\n\n#       i. First, let\u2019s create a vector called important_genes with the Ensembl IDs of the 6 genes we are interested in:\n\n        important_genes &lt;- c(\"ENSMUSG00000083700\", \"ENSMUSG00000080990\", \"ENSMUSG00000065619\", \"ENSMUSG00000047945\", \"ENSMUSG00000081010\", \"ENSMUSG00000030970\")\n\n#       ii. Use the %in% operator to determine if all of these genes are present in the row names of the rpkm_data data frame.\nimportant_genes %in% rownames(rpkm_data)\n\n#       iii. Extract the rows from rpkm_data that correspond to these 6 genes using [] and the %in% operator. Double check the row names to ensure that you are extracting the correct rows.\nidx &lt;- rownames(rpkm_data) %in% important_genes\nans &lt;- rpkm_data[idx, ]\nidx2 &lt;- which(rownames(rpkm_data) %in% important_genes)\nans2 &lt;- rpkm_data[idx2, ]\n\n#       iv. Bonus question: Extract the rows from rpkm_data that correspond to these 6 genes using [], but without using the %in% operator.\nans3 &lt;- rpkm_data[important_genes, ]\n</code></pre>"},{"location":"day_4_exercise_n_answer_keys/Day2_Homework_Answer-Key/#reordering-and-matching","title":"Reordering and matching","text":"<pre><code># 1. Now that we know how to reorder using indices, let\u2019s try to use it to reorder the contents of one vector to match the contents of another. Let\u2019s create the vectors first and second as detailed below:\nfirst &lt;- c(\"A\",\"B\",\"C\",\"D\",\"E\")\nsecond &lt;- c(\"B\",\"D\",\"E\",\"A\",\"C\")  # same letters but different order\n\n#        How would you reorder the second vector to match first?\nsecond[c(4, 1, 5, 2, 3)]\n\n# 2. After talking with your collaborator, it becomes clear that sample2 and sample9 were actually from a different mouse background than the other samples and should not be part of our analysis. Create a new variable called subset_rpkm that has these columns removed from the rpkm_ordered data frame.\nsubset_rpkm &lt;- rpkm_ordered[ , c(1,3:8,10:12)]  #or\nsubset_rpkm &lt;- rpkm_ordered[ , -c(2,9)]\n\n# 3. Use the match() function to subset the metadata data frame so that the row names of the metadata data frame match the column names of the subset_rpkm data frame.  \nidx &lt;- match(colnames(subset_rpkm), rownames(metadata))\nmetadata[idx, ]\n</code></pre> <p>Attribution notice</p> <ul> <li> <p>This lesson has been developed by members of the teaching team at the Harvard Chan Bioinformatics Core (HBC). These are open access materials distributed under the terms of the Creative Commons Attribution license (CC BY 4.0), which permits unrestricted use, distribution, and reproduction in any medium, provided the original author and source are credited.</p> </li> <li> <p>The materials used in this lesson are adapted from work that is Copyright \u00a9 Data Carpentry (http://datacarpentry.org/).</p> </li> <li> <p>All Data Carpentry instructional material is made available under the Creative Commons Attribution license (CC BY 4.0).</p> </li> </ul>"},{"location":"day_4_exercise_n_answer_keys/Day3_Homework_Answer-Key/","title":"Day3 Homework Answer Key","text":""},{"location":"day_4_exercise_n_answer_keys/Day3_Homework_Answer-Key/#ggplot2-exercise","title":"ggplot2 exercise","text":""},{"location":"day_4_exercise_n_answer_keys/Day3_Homework_Answer-Key/#creating-a-boxplot","title":"Creating a boxplot","text":"<pre><code>#1. boxplot\nggplot(new_metadata) +\n  geom_boxplot(aes(x = genotype, y = samplemeans, fill = celltype)) +\n  ggtitle(\"Genotype differences in average gene expression\") +\n  xlab(\"Genotype\") +\n  ylab(\"Mean expression\") +\n  theme_bw() +\n  theme(axis.title = element_text(size = rel(1.25))) +\n  theme(plot.title=element_text(hjust = 0.5, size = rel(1.5)))\n\n#2. Changing the order of genotype\nnew_metadata$genotype &lt;- factor(new_metadata$genotype, levels = c(\"Wt\", \"KO\"))\n\n#3. Changing default colors\n\n#Add a new layer scale_color_manual(values=c(\"purple\",\"orange\")).\n#Do you observe a change?\n    ## No\n\n#Replace scale_color_manual(values=c(\"purple\",\"orange\")) with scale_fill_manual(values=c(\"purple\",\"orange\")).\n#Do you observe a change?\n    ## Yes\n\n#In the scatterplot we drew in class, add a new layer scale_color_manual(values=c(\"purple\",\"orange\")), do you observe a difference?\n    ## Yes\n\n#What do you think is the difference between scale_color_manual() and scale_fill_manual()?\n    ## scale_color_manual() works with scatter plot, and scale_fill_#manual() works with box plot is what it appears to be\n    ## \n    ## Actually, scale_color_manual() works if the \"color\" argument is used , whereas scale_fill_manual() works if the \"fill\" argument is used\n\n\n## Boxplot using \"color\" instead of \"fill\"\nggplot(new_metadata) +\n  geom_boxplot(aes(x = genotype, y = samplemeans, color = celltype)) +\n  ggtitle(\"Genotype differences in average gene expression\") +\n  xlab(\"Genotype\") +\n  ylab(\"Mean expression\") +\n  theme_bw() +\n  theme(axis.title = element_text(size = rel(1.25))) +\n  theme(plot.title=element_text(hjust = 0.5, size = rel(1.5))) +\n  scale_color_manual(values=c(\"purple\",\"orange\"))\n\n\n#Back in your boxplot code, change the colors in the scale_fill_manual() layer to be your 2 favorite colors.\n#Are there any colors that you tried that did not work?\n\n  ggplot(new_metadata) +\n  geom_boxplot(aes(x = genotype, y = samplemeans, fill = celltype)) +\n  ggtitle(\"Genotype differences in average gene expression\") +\n  xlab(\"Genotype\") +\n  ylab(\"Mean expression\") +\n  theme_bw() +\n  theme(axis.title = element_text(size = rel(1.25))) +\n  theme(plot.title=element_text(hjust = 0.5, size = rel(1.5))) +\n  scale_fill_manual(values=c(\"red\", \"blue\"))\n\n#OPTIONAL Exercise:\n#Find the hexadecimal code for your 2 favourite colors (from exercise 3 above) and replace the color names with the hexadecimal codes within the ggplot2 code chunk.\nscale_fill_manual(values=c(\"#FF3333\", \"#3333FF\"))\n</code></pre>"},{"location":"day_4_exercise_n_answer_keys/Day3_Homework_Answer-Key/#finding-help","title":"Finding help","text":"<p>Exercises Run the following code chunks and fix all of the errors. (Note: The code chunks are independent from one another.)</p>"},{"location":"day_4_exercise_n_answer_keys/Day3_Homework_Answer-Key/#create-vector-of-work-days","title":"Create vector of work days","text":"<pre><code>#work_days &lt;- c(Monday, Tuesday, Wednesday, Thursday, Friday)\nwork_days &lt;- c(\"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\")\n</code></pre>"},{"location":"day_4_exercise_n_answer_keys/Day3_Homework_Answer-Key/#create-a-function-to-round-the-output-of-the-sum-function","title":"Create a function to round the output of the sum function","text":"<pre><code>#round_the_sum &lt;- function(x){\n#  return(round(sum(x))\n#}\nround_the_sum &lt;- function(x){\n  return(round(sum(x)))\n}\n</code></pre>"},{"location":"day_4_exercise_n_answer_keys/Day3_Homework_Answer-Key/#create-a-function-to-add-together-three-numbers","title":"Create a function to add together three numbers","text":"<pre><code>#add_numbers &lt;- function(x,y,z){\n#  sum(x,y,z)\n#}\n#add_numbers(5,9)\nadd_numbers(5,9,6)\n</code></pre>"},{"location":"day_4_exercise_n_answer_keys/Day3_Homework_Answer-Key/#you-try-to-install-a-package-and-you-get-the-following-error-message","title":"You try to install a package and you get the following error message:","text":"<p>Error</p> <pre><code>Error: package or namespace load failed for 'Seurat' in loadNamespace(j &lt;- i[[1L]], c(lib.loc, .libPaths()), versionCheck = vI[[j]]): there is no package called 'multtest'\n</code></pre> <p>What would you do to remedy the error?</p>"},{"location":"day_4_exercise_n_answer_keys/Day3_Homework_Answer-Key/#install-multtest-first-and-then-install-seurat-package","title":"Install multtest first, and then install seurat package:","text":"<p><pre><code>BiocManager::install('multtest')\ninstall.packages('Seurat')\n</code></pre> You would like to ask for help on an online forum. To do this you want the users of the forum to reproduce your problem, so you want to provide them as much relevant information and data as possible.</p> <p>You want to provide them with the list of packages that you currently have loaded, the version of R, your OS and package versions. Use the appropriate function(s) to obtain this information.</p> <pre><code>sessionInfo()\n</code></pre> <p>You want to also provide a small data frame that reproduces the error (if working with a large data frame, you\u2019ll need to subset it down to something small). For this exercse use the data frame df, and save it as an RData object called df.RData.</p> <pre><code>save(df, file = \"data/df.RData\")\n# What code should the people looking at your help request should use to read in df.RData?\nload(file=\"data/df.RData\")\n</code></pre>"},{"location":"day_4_exercise_n_answer_keys/Day3_Homework_Answer-Key/#tidyverse","title":"Tidyverse","text":"<p>Create a vector of random numbers using the code below: <pre><code>random_numbers &lt;- c(81, 90, 65, 43, 71, 29)\n</code></pre></p> <p>Use the pipe (%&gt;%) to perform two steps in a single line. Take the mean of random_numbers using the mean() function. <pre><code>random_numbers %&gt;% mean()\n</code></pre> Round the output to three digits using the round() function. <pre><code>random_numbers %&gt;% \n  mean() %&gt;% \n  round(digits = 3)\n</code></pre> We would like to perform an additional round of filtering to only keep the most specific GO terms. For bp_oe, use the filter() function to only keep those rows where the relative.depth is greater than 4. Save output to overwrite our bp_oe variable. <pre><code>bp_oe &lt;- bp_oe %&gt;% \n  filter(relative.depth &gt; 4)\n</code></pre></p> <p>Using Base R </p> <pre><code># bp_oe &lt;- subset(bp_oe, relative.depth &gt; 4)\n</code></pre> <p>Rename the intersection column to genes to reflect the fact that these are the DE genes associated with the GO process. <pre><code>bp_oe &lt;- bp_oe %&gt;% \n  dplyr::rename(genes = intersection)\n</code></pre> Using Base R  <pre><code>colnames(bp_oe)[colnames(bp_oe) == \"intersection\"] &lt;- \"genes\"\n</code></pre></p> <p>Create a column in bp_oe called term_percent to determine the percent of DE genes associated with the GO term relative to the total number of genes associated with the GO term (overlap.size / term.size)</p> <p><pre><code>bp_oe &lt;- bp_oe %&gt;% \n  mutate(term_percent = overlap.size / term.size)\n</code></pre> Using Base R</p> <pre><code>bp_oe &lt;- cbind(bp_oe, term_percent = bp_oe$overlap.size / bp_oe$term.size)\n</code></pre> <p>Attribution notice</p> <ul> <li> <p>This lesson has been developed by members of the teaching team at the Harvard Chan Bioinformatics Core (HBC). These are open access materials distributed under the terms of the Creative Commons Attribution license (CC BY 4.0), which permits unrestricted use, distribution, and reproduction in any medium, provided the original author and source are credited.</p> </li> <li> <p>The materials used in this lesson are adapted from work that is Copyright \u00a9 Data Carpentry (http://datacarpentry.org/).</p> </li> <li> <p>All Data Carpentry instructional material is made available under the Creative Commons Attribution license (CC BY 4.0).</p> </li> </ul>"},{"location":"day_4_exercise_n_answer_keys/Day4_Intro_to_R_Answer-Key/","title":"Day4 Intro to R Answer Key","text":""},{"location":"day_4_exercise_n_answer_keys/Day4_Intro_to_R_Answer-Key/#homework-answer-key-introduction-to-r-practice","title":"Homework answer key - Introduction to R practice","text":""},{"location":"day_4_exercise_n_answer_keys/Day4_Intro_to_R_Answer-Key/#creating-vectorsfactors-and-dataframes","title":"Creating vectors/factors and dataframes","text":"<ol> <li> <p>We are performing RNA-Seq on cancer samples being treated with three different types of treatment (A, B, and P). You have 12 samples total, with 4 replicates per treatment. Write the R code you would use to construct your metadata table as described below.  </p> <ul> <li>Create the vectors/factors for each column (Hint: you can type out each vector/factor, or if you want the process go faster try exploring the <code>rep()</code> function).</li> </ul> <pre><code>sex &lt;- c(\"M\", \"F\",...) # saved vectors/factors as variables and used c() or rep() function to create\n</code></pre> <ul> <li>Put them together into a dataframe called <code>meta</code>.</li> </ul> <p><pre><code>meta &lt;- data.frame(sex, stage, treatment, myc) # used data.frame() to create the table\n</code></pre>  - Use the <code>rownames()</code> function to assign row names to the dataframe (Hint: you can type out the row names as a vector, or if you want the process go faster try exploring the <code>paste()</code> function).</p> <pre><code>rownames(meta) &lt;- c(\"sample1\", \"sample2\",... , \"sample12\") # or use:\n\nrownames(meta) &lt;- paste(\"sample12\", 1:12, sep=\"\")\n</code></pre> <p>Your finished metadata table should have information for the variables <code>sex</code>, <code>stage</code>, <code>treatment</code>, and <code>myc</code> levels: </p> sex stage treatment myc sample1 M I A 2343 sample2 F II A 457 sample3 M II A 4593 sample4 F I A 9035 sample5 M II B 3450 sample6 F II B 3524 sample7 M I B 958 sample8 F II B 1053 sample9 M II P 8674 sample10 F I P 3424 sample11 M II P 463 sample12 F II P 5105 </li> </ol>"},{"location":"day_4_exercise_n_answer_keys/Day4_Intro_to_R_Answer-Key/#subsetting-vectorsfactors-and-dataframes","title":"Subsetting vectors/factors and dataframes","text":"<ol> <li> <p>Using the <code>meta</code> data frame from question #1, write out the R code you would use to perform the following operations (questions DO NOT build upon each other):</p> <ul> <li>return only the <code>treatment</code> and <code>sex</code> columns using <code>[]</code>:</li> </ul> <pre><code>meta[ , c(1,3)]\n</code></pre> <ul> <li>return the <code>treatment</code> values for samples 5, 7, 9, and 10 using <code>[]</code>:</li> </ul> <pre><code>meta[c(5,7,9,10), 3]\n</code></pre> <ul> <li>use <code>filter()</code> to return all data for those samples receiving treatment <code>P</code>:</li> </ul> <pre><code>filter(meta, treatment == \"P\")\n</code></pre> <ul> <li>use <code>filter()</code>/<code>select()</code> to return only the <code>stage</code> and <code>treatment</code> data for those samples with <code>myc</code> &gt; 5000:</li> </ul> <pre><code>filter(meta, myc &gt; 5000) %&gt;% select(stage, treatment)\n</code></pre> <ul> <li>remove the <code>treatment</code> column from the dataset using <code>[]</code>:</li> </ul> <pre><code>meta[, -3]\n</code></pre> <ul> <li>remove samples 7, 8 and 9 from the dataset using <code>[]</code>:</li> </ul> <pre><code>meta[-7:-9, ]\n</code></pre> <ul> <li>keep only samples 1-6 using <code>[]</code>:</li> </ul> <pre><code>meta [1:6, ]\n</code></pre> <ul> <li>add a column called <code>pre_treatment</code> to the beginning of the dataframe with the values T, F, F, F, T, T, F, T, F, F, T, T (Hint: use <code>cbind()</code>): </li> </ul> <pre><code>pre_treatment &lt;- c(T, F, F, F, T, T, F, T, F, F, T, T)\n\ncbind(pre_treatment, meta)\n</code></pre> <ul> <li>change the names of the columns to: \"A\", \"B\", \"C\", \"D\":</li> </ul> <pre><code>colnames(meta) &lt;- c(\"A\", \"B\", \"C\", \"D\")\n</code></pre> </li> </ol>"},{"location":"day_4_exercise_n_answer_keys/Day4_Intro_to_R_Answer-Key/#extracting-components-from-lists","title":"Extracting components from lists","text":"<ol> <li> <p>Create a new list, <code>list_hw</code> with three components, the <code>glengths</code> vector, the dataframe <code>df</code>, and <code>number</code> value. Use this list to answer the questions below . <code>list_hw</code> has the following structure (NOTE: the components of this list are not currently named):</p> <p><pre><code>[[1]]\n[1]   4.6  3000.0 50000.0 \n\n[[2]]\n          species  glengths \n     1    ecoli    4.6\n     2    human    3000.0\n     3    corn     50000.0\n\n[[3]]\n[1] 8\n</code></pre> Write out the R code you would use to perform the following operations (questions DO NOT build upon each other):  - return the second component of the list:</p> <pre><code>list_hw[[2]]\n</code></pre> <ul> <li>return <code>50000.0</code> from the first component of the list:</li> </ul> <pre><code>list_hw[[1]][3]\n</code></pre> <ul> <li>return the value <code>human</code> from the second component: </li> </ul> <pre><code>list_hw[[2]][2, 1]\n</code></pre> <ul> <li>give the components of the list the following names: \"genome_lengths\", \"genomes\", \"record\":</li> </ul> <pre><code>names(list_hw) &lt;- c(\"genome_lengths\",\"genomes\",\"record\")\n\nlist_hw$record\n</code></pre> </li> </ol>"},{"location":"day_4_exercise_n_answer_keys/Day4_Intro_to_R_Answer-Key/#creating-figures-with-ggplot2","title":"Creating figures with ggplot2","text":"<ol> <li>Create the same plot as above using ggplot2 using the provided metadata and counts datasets. The metadata table describes an experiment that you have setup for RNA-seq analysis, while the associated count matrix gives the normalized counts for each sample for every gene. Download the count matrix and metadata using the links provided.</li> </ol> <p>Follow the instructions below to build your plot. Write the code you used and provide the final image.</p> <ul> <li> <p>Read in the metadata file using: <code>meta &lt;- read.delim(\"Mov10_full_meta.txt\", sep=\"\\t\", row.names=1)</code></p> </li> <li> <p>Read in the count matrix file using: <code>data &lt;- read.delim(\"normalized_counts.txt\", sep=\"\\t\", row.names=1)</code></p> </li> <li> <p>Create a vector called <code>expression</code> that contains the normalized count values from the row in <code>data</code> that corresponds to the <code>MOV10</code> gene.  </p> </li> </ul> <pre><code>expression &lt;- data[\"MOV10\", ]\n</code></pre> <ul> <li>Check the class of this expression vector. <code>data.frame</code></li> </ul> <p>Then, will need to convert this to a numeric vector using <code>as.numeric(expression)</code></p> <pre><code>class(expression)\n\nexpression &lt;- as.numeric(expression)\n\nclass(expression)\n</code></pre> <ul> <li>Bind that vector to your metadata data frame (<code>meta</code>) and call the new data frame <code>df</code>. </li> </ul> <pre><code>df &lt;- cbind(meta, expression) #or\n\ndf &lt;- data.frame(meta, expression)\n</code></pre> <ul> <li> <p>Create a ggplot by constructing the plot line by line:</p> <ul> <li> <p>Initialize a  ggplot with your <code>df</code> as input.</p> </li> <li> <p>Add the <code>geom_jitter()</code> geometric object with the required aesthetics</p> </li> <li> <p>Color the points based on <code>sampletype</code></p> </li> <li> <p>Add the <code>theme_bw()</code> layer </p> </li> <li> <p>Add the title \"Expression of MOV10\" to the plot</p> </li> <li> <p>Change the x-axis label to be blank</p> </li> <li> <p>Change the y-axis label to \"Normalized counts\"</p> </li> <li> <p>Using <code>theme()</code> change the following properties of the plot:</p> <ul> <li> <p>Remove the legend (Hint: use ?theme help and scroll down to legend.position)</p> </li> <li> <p>Change the plot title size to 1.5x the default and center align</p> </li> <li> <p>Change the axis title to 1.5x the default size</p> </li> <li> <p>Change the size of the axis text only on the y-axis to 1.25x the default size</p> </li> <li> <p>Rotate the x-axis text to 45 degrees using <code>axis.text.x=element_text(angle=45, hjust=1)</code></p> </li> </ul> </li> </ul> <p><pre><code>ggplot(df) +\n     geom_jitter(aes(x= sampletype, y= expression, color = sampletype)) +\n     theme_bw() +\n     ggtitle(\"Expression of MOV10\") +\n     xlab(NULL) +\n     ylab(\"Normalized counts\") +\n     theme(legend.position = \"none\",\n          plot.title=element_text(hjust=0.5, size=rel(1.5)),\n          axis.text=element_text(size=rel(1.25)),\n          axis.title=element_text(size=rel(1.5)),\n          axis.text.x=element_text(angle=45, hjust=1))\n</code></pre> </p> </li> </ul> <p>Attribution notice</p> <ul> <li> <p>This lesson has been developed by members of the teaching team at the Harvard Chan Bioinformatics Core (HBC). These are open access materials distributed under the terms of the Creative Commons Attribution license (CC BY 4.0), which permits unrestricted use, distribution, and reproduction in any medium, provided the original author and source are credited.</p> </li> <li> <p>The materials used in this lesson are adapted from work that is Copyright \u00a9 Data Carpentry (http://datacarpentry.org/).</p> </li> <li> <p>All Data Carpentry instructional material is made available under the Creative Commons Attribution license (CC BY 4.0).</p> </li> </ul>"}]}